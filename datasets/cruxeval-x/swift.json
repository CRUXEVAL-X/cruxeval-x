[
    {
        "id": 0,
        "code": "\n/// \nfunc f(nums: [Int]) -> [(Int, Int)] {\n    var output: [(Int, Int)] = []\n    for n in nums {\n        output.append((nums.filter{$0 == n}.count, n))\n    }\n    output.sort { $0.0 > $1.0 }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1, 3, 1, 3, 1]) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)])"
    },
    {
        "id": 1
    },
    {
        "id": 2,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var new_text = Array(text)\n    new_text.removeAll(where: { $0 == \"+\" })\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"hbtofdeiequ\") == \"hbtofdeiequ\")"
    },
    {
        "id": 3,
        "code": "\n/// \nfunc f(text: String, value: String) -> String {\n    var textList = Array(text)\n    textList.append(contentsOf: value)\n    return textList.reduce(\"\", { $0 + String($1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"bcksrut\", value: \"q\") == \"bcksrutq\")"
    },
    {
        "id": 4,
        "code": "\n/// \nfunc f(array: [String]) -> String {\n    var s = \" \"\n    s += array.joined()\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [\" \", \"  \", \"    \", \"   \"]) == \"           \")"
    },
    {
        "id": 5,
        "code": "\nfunc f(text: String, lower: String, upper: String) -> (Int, String) {\n    var count = 0\n    var new_text: [Character] = []\n    for char in text {\n        let newChar = char.isNumber ? Character(lower) : Character(upper)\n        if [\"p\", \"C\"].contains(newChar) {\n            count += 1\n        }\n        new_text.append(newChar)\n    }\n    return (count, String(new_text))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"DSUWeqExTQdCMGpqur\", lower: \"a\", upper: \"x\") == (0, \"xxxxxxxxxxxxxxxxxx\"))"
    },
    {
        "id": 6
    },
    {
        "id": 7,
        "code": "\n\n/// \nfunc f(list: [Int]) -> [Int] {\n    var list = list\n    var original = list\n    while list.count > 1 {\n        list.removeLast()\n        for i in 0..<list.count {\n            list.remove(at: i)\n        }\n    }\n    list = original\n    if !list.isEmpty {\n        list.removeFirst()\n    }\n    return list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(list: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 8,
        "code": "\n\n/// \nfunc f(string: String, encryption: Int) -> String {\n    if encryption == 0 {\n        return string\n    } else {\n        return string.uppercased()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"UppEr\", encryption: 0) == \"UppEr\")"
    },
    {
        "id": 9,
        "code": "\n/// \nfunc f(t: String) -> Bool {\n    for c in t {\n        if !c.isNumber {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(t: \"#284376598\") == false)"
    },
    {
        "id": 10,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    return text.lowercased().filter{ \"ÄäÏïÖ�Ü�\".contains($0) || $0.isNumber }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\") == \"\")"
    },
    {
        "id": 11,
        "code": "\nfunc f(a: [String : [String]], b: [String : String]) -> [String : [String]] {\n    var mutableA = a\n    for (key, value) in b {\n        if mutableA[key] == nil {\n            mutableA[key] = [value]\n        } else {\n            mutableA[key]?.append(value)\n        }\n    }\n    return mutableA\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: [:] as [String : [String]], b: [\"foo\" : \"bar\"]) == [\"foo\" : [\"bar\"]])"
    },
    {
        "id": 12,
        "code": "\n/// \nfunc f(s: String, x: String) -> String {\n    var count = 0\n    var newString = s\n    while newString.prefix(x.count) == x && count < s.count - x.count {\n        newString = String(newString.dropFirst(x.count))\n        count += x.count\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"If you want to live a happy life! Daniel\", x: \"Daniel\") == \"If you want to live a happy life! Daniel\")"
    },
    {
        "id": 13
    },
    {
        "id": 14,
        "code": "import Foundation\n\nfunc f(s: String) -> String {\n    var arr = Array(s.trimmingCharacters(in: .whitespaces))\n    arr.reverse()\n    return String(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"   OOP   \") == \"POO\")"
    },
    {
        "id": 15,
        "code": "import Foundation\n\nfunc f(text: String, wrong: String, right: String) -> String {\n    let newText = text.replacingOccurrences(of: wrong, with: right)\n    return newText.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"zn kgd jw lnt\", wrong: \"h\", right: \"u\") == \"ZN KGD JW LNT\")"
    },
    {
        "id": 16,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    if text.hasSuffix(suffix) {\n        return String(text.dropLast(suffix.count))\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"zejrohaj\", suffix: \"owc\") == \"zejrohaj\")"
    },
    {
        "id": 17,
        "code": "func f(text: String) -> Int {\n    if let index = text.firstIndex(of: \",\") {\n        return text.distance(from: text.startIndex, to: index)\n    } else {\n        return -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"There are, no, commas, in this text\") == 9)"
    },
    {
        "id": 18,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> [Int] {\n    var k = 0\n    var newArray = array\n    for i in newArray {\n        if i > elem {\n            newArray.insert(elem, at: k)\n            break\n        }\n        k += 1\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [5, 4, 3, 2, 1, 0], elem: 3) == [3, 5, 4, 3, 2, 1, 0])"
    },
    {
        "id": 19,
        "code": "\n/// \nfunc f(x: String, y: String) -> String {\n    let tmp = String(y.reversed().map { $0 == \"9\" ? \"0\" : \"9\" })\n    if let _ = Int(x), let _ = Int(tmp) {\n        return x + tmp\n    } else {\n        return x\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: \"\", y: \"sdasdnakjsda80\") == \"\")"
    },
    {
        "id": 20,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var result = \"\"\n    for i in stride(from: text.count-1, through: 0, by: -1) {\n        result += String(text[text.index(text.startIndex, offsetBy: i)])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"was,\") == \",saw\")"
    },
    {
        "id": 21,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var newArray = array\n    let n = newArray.removeLast()\n    newArray.append(contentsOf: [n, n])\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 1, 2, 2]) == [1, 1, 2, 2, 2])"
    },
    {
        "id": 22,
        "code": "\nextension Int: Error {}\n        \n/// \nfunc f(a: Int) -> Result<[Int], Int> {\nif a == 0 {\n        return .success([0])\n    }\n    var result = [Int]()\n    var tempA = a\n    while tempA > 0 {\n        result.append(tempA % 10)\n        tempA = tempA / 10\n    }\n    result.reverse()\n    let resultString = result.map { String($0) }.joined()\n    guard let resultInt = Int(resultString) else {\n        return .failure(a)\n    }\n    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: 0) == .success([0]))"
    },
    {
        "id": 23,
        "code": "import Foundation\n\nfunc f(text: String, chars: String) -> String {\n    var text = text\n    if !chars.isEmpty {\n        text = text.trimmingCharacters(in: CharacterSet(charactersIn: chars))\n    } else {\n        text = text.trimmingCharacters(in: .whitespaces)\n    }\n    if text.isEmpty {\n        return \"-\"\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"new-medium-performing-application - XQuery 2.2\", chars: \"0123456789-\") == \"new-medium-performing-application - XQuery 2.\")"
    },
    {
        "id": 24,
        "code": "\n/// \nfunc f(nums: [Int], i: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.remove(at: i)\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [35, 45, 3, 61, 39, 27, 47], i: 0) == [45, 3, 61, 39, 27, 47])"
    },
    {
        "id": 25,
        "code": "\n\nfunc f(d: [String : Int]) -> [String : Int] {\n    var dCopy = d\n    dCopy.remove(at: dCopy.startIndex)\n    return dCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"l\" : 1, \"t\" : 2, \"x:\" : 3]) == [\"l\" : 1, \"t\" : 2])"
    },
    {
        "id": 26
    },
    {
        "id": 27,
        "code": "\n/// \nfunc f(w: String) -> Bool {\n    var ls = Array(w)\n    var omw = \"\"\n    while ls.count > 0 {\n        omw += String(ls.removeFirst())\n        if ls.count * 2 > w.count {\n            return w.dropFirst(ls.count) == omw\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(w: \"flak\") == false)"
    },
    {
        "id": 28,
        "code": "\n/// \nfunc f(mylist: [Int]) -> Bool {\n    var revl = mylist\n    revl.reverse()\n    var sortedList = mylist.sorted(by: >)\n    return sortedList == revl\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(mylist: [5, 8]) == true)"
    },
    {
        "id": 29,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let nums = text.filter { $0.isNumber }\n    assert(nums.count > 0)\n    return String(nums)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"-123   \\t+314\") == \"123314\")"
    },
    {
        "id": 30,
        "code": "\nextension Int: Error {}\n        \n/// \nfunc f(array: [Result<String, Int>]) -> [Result<String, Int>] {\n    var result = [Result<String, Int>]()\n    for elem in array {\n        if case let .success(value) = elem {\n            if let intValue = Int(value), !String(abs(intValue)).contains(where: { !$0.isASCII }) {\n                result.append(.success(value))\n            } else if value.allSatisfy({ $0.isASCII }) {\n                result.append(.success(value))\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [.success(\"a\"), .success(\"b\"), .success(\"c\")]) == [.success(\"a\"), .success(\"b\"), .success(\"c\")])"
    },
    {
        "id": 31,
        "code": "\n/// \nfunc f(string: String) -> Int {\n    var upper = 0\n    for c in string {\n        if c.isUppercase {\n            upper += 1\n        }\n    }\n    return upper * (upper % 2 == 0 ? 2 : 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"PoIOarTvpoead\") == 8)"
    },
    {
        "id": 32,
        "code": "func f(s: String, sep: String) -> String {\n    let reverse = s.split(separator: Character(sep)).map { \"*\" + String($0) }\n    return reverse.reversed().joined(separator: \";\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"volume\", sep: \"l\") == \"*ume;*vo\")"
    },
    {
        "id": 33
    },
    {
        "id": 34,
        "code": "\n/// \nfunc f(nums: [Int], odd1: Int, odd2: Int) -> [Int] {\n    var nums = nums\n    while nums.contains(odd1) {\n        if let index = nums.firstIndex(of: odd1) {\n            nums.remove(at: index)\n        }\n    }\n    while nums.contains(odd2) {\n        if let index = nums.firstIndex(of: odd2) {\n            nums.remove(at: index)\n        }\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 3, 7, 7, 6, 8, 4, 1, 2, 3, 5, 1, 3, 21, 1, 3], odd1: 3, odd2: 1) == [2, 7, 7, 6, 8, 4, 2, 5, 21])"
    },
    {
        "id": 35
    },
    {
        "id": 36,
        "code": "import Foundation\n\nfunc f(text: String, chars: String) -> String {\n    return text.trimmingCharacters(in: CharacterSet(charactersIn: chars))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ha\", chars: \"\") == \"ha\")"
    },
    {
        "id": 37,
        "code": "\n/// \nfunc f(text: String) -> [String] {\n    var text_arr: [String] = []\n    for j in 0..<text.count {\n        text_arr.append(String(text.suffix(text.count - j)))\n    }\n    return text_arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"123\") == [\"123\", \"23\", \"3\"])"
    },
    {
        "id": 38
    },
    {
        "id": 39,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> Int {\n    if let index = array.firstIndex(of: elem) {\n        return index\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [6, 2, 7, 1], elem: 6) == 0)"
    },
    {
        "id": 40,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    var output = text\n    output.append(\"#\")\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"the cow goes moo\") == \"the cow goes moo#\")"
    },
    {
        "id": 41,
        "code": "\n/// \nfunc f(array: [Int], values: [Int]) -> [Int] {\n    var newArray = array\n    newArray.reverse()\n    for value in values {\n        newArray.insert(value, at: newArray.count / 2)\n    }\n    newArray.reverse()\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [58], values: [21, 92]) == [58, 92, 21])"
    },
    {
        "id": 42,
        "code": "\nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    nums.removeAll()\n    for num in nums {\n        nums.append(num * 2)\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [4, 3, 2, 1, 2, -1, 4, 2]) == [] as [Int])"
    },
    {
        "id": 43,
        "code": "\n/// \nfunc f(n: String) -> Int {\n    for i in n {\n        if !i.isNumber {\n            return -1\n        }\n    }\n    return Int(n) ?? -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: \"6 ** 2\") == -1)"
    },
    {
        "id": 44
    },
    {
        "id": 45,
        "code": "\n/// \nfunc f(text: String, letter: String) -> Int {\n    var counts: [Character: Int] = [:]\n    for char in text {\n        if counts[char] == nil {\n            counts[char] = 1\n        } else {\n            counts[char]! += 1\n        }\n    }\n    return counts[Character(letter)] ?? 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"za1fd1as8f7afasdfam97adfa\", letter: \"7\") == 2)"
    },
    {
        "id": 46,
        "code": "\n/// \nfunc f(l: [String], c: String) -> String {\n    return l.joined(separator: c)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(l: [\"many\", \"letters\", \"asvsz\", \"hello\", \"man\"], c: \"\") == \"manylettersasvszhelloman\")"
    },
    {
        "id": 47,
        "code": "\n\nimport Foundation\n\nfunc f(text: String) -> Bool {\n    let length = text.count\n    let half = length / 2\n    let firstHalf = text.prefix(half)\n    let secondHalf = text.dropFirst(half)\n    if let encodedFirstHalf = firstHalf.data(using: .ascii),\n       let decodedSecondHalf = String(data: encodedFirstHalf, encoding: .ascii) {\n        return decodedSecondHalf == secondHalf\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"bbbbr\") == false)"
    },
    {
        "id": 48,
        "code": "\n/// \nfunc f(names: [String]) -> String {\n    guard !names.isEmpty else { return \"\" }\n    var smallest = names[0]\n    for name in names[1...] {\n        if name < smallest {\n            smallest = name\n        }\n    }\n    if let index = names.firstIndex(of: smallest) {\n        var namesCopy = names\n        namesCopy.remove(at: index)\n        return namesCopy.joined()\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(names: [] as [String]) == \"\")"
    },
    {
        "id": 49,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    if text.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) == nil {\n        return String(text.filter { $0.isNumber })\n    } else {\n        return String(text)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"816\") == \"816\")"
    },
    {
        "id": 50,
        "code": "func f(lst: [String]) -> [Int] {\n    var lst = lst\n    lst.removeAll()\n    let result = Array(repeating: 1, count: lst.count + 1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [\"a\", \"c\", \"v\"]) == [1])"
    },
    {
        "id": 51,
        "code": "\nextension Int: Error {}\n        \n/// \nfunc f(num: Int) -> Result<String, Int> {\n    let s = String(repeating: \"<\", count: 10)\n    if num % 2 == 0 {\n        return Result.success(s)\n    } else {\n        return Result.failure(num - 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: 21) == .failure(20))"
    },
    {
        "id": 52,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var a = \"\"\n    for char in text {\n        if !char.isNumber {\n            a.append(char)\n        }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"seiq7229 d27\") == \"seiq d\")"
    },
    {
        "id": 53,
        "code": "\n/// \nfunc f(text: String) -> [Int] {\n    var occ: [String: Int] = [:]\n    for ch in text {\n        let name = [\"a\": \"b\", \"b\": \"c\", \"c\": \"d\", \"d\": \"e\", \"e\": \"f\"]\n        let updatedName = name[String(ch)] ?? String(ch)\n        occ[updatedName, default: 0] += 1\n    }\n    return occ.values.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"URW rNB\") == [1, 1, 1, 1, 1, 1, 1])"
    },
    {
        "id": 54,
        "code": "\n/// \nfunc f(text: String, s: Int, e: Int) -> Int {\n    let sublist = text[text.index(text.startIndex, offsetBy: s)..<text.index(text.startIndex, offsetBy: e)]\n    if sublist.isEmpty {\n        return -1\n    }\n    return text.distance(from: text.startIndex, to: sublist.firstIndex(of: sublist.min()!)!)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"happy\", s: 0, e: 3) == 1)"
    },
    {
        "id": 55,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var array_2: [Int] = []\n    \n    for i in array {\n        if i > 0 {\n            array_2.append(i)\n        }\n    }\n    \n    array_2.sort(by: >)\n    \n    return array_2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [4, 8, 17, 89, 43, 14]) == [89, 43, 17, 14, 8, 4])"
    },
    {
        "id": 56,
        "code": "\n/// \nfunc f(sentence: String) -> Bool {\n    for c in sentence {\n        if !c.unicodeScalars.allSatisfy({ $0.isASCII }) {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(sentence: \"1z1z1\") == true)"
    },
    {
        "id": 57,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var text = text.uppercased()\n    var count_upper = 0\n    for char in text {\n        if char.isUppercase {\n            count_upper += 1\n        } else {\n            return -1\n        }\n    }\n    return count_upper / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ax\") == 1)"
    },
    {
        "id": 58,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var result = nums\n    let count = nums.count\n    \n    for i in 0..<count {\n        result.append(nums[i % 2])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-1, 0, 0, 1, 1]) == [-1, 0, 0, 1, 1, -1, 0, -1, 0, -1])"
    },
    {
        "id": 59,
        "code": "\n/// \nfunc f(s: String) -> String {\n    var a = s.filter { $0 != \" \" }\n    var b = a\n    for c in a.reversed() {\n        if c == \" \" {\n            b.removeLast()\n        } else {\n            break\n        }\n    }\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"hi \") == \"hi\")"
    },
    {
        "id": 60,
        "code": "\n/// \nfunc f(doc: String) -> String {\n    for x in doc {\n        if x.isLetter {\n            return x.uppercased()\n        }\n    }\n    return \"-\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(doc: \"raruwa\") == \"R\")"
    },
    {
        "id": 61
    },
    {
        "id": 62
    },
    {
        "id": 63,
        "code": "\n/// \nfunc f(text: String, prefix: String) -> String {\n    var text = text\n    while text.hasPrefix(prefix) {\n        let prefixCount = prefix.count\n        let startIndex = text.index(text.startIndex, offsetBy: prefixCount)\n        text = String(text[startIndex...]) ?? text\n    }\n    \n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ndbtdabdahesyehu\", prefix: \"n\") == \"dbtdabdahesyehu\")"
    },
    {
        "id": 64,
        "code": "\n/// \nfunc f(text: String, size: Int) -> String {\n    var counter = text.count\n    var text = text\n    let halfSize = Int(size) / 2\n    \n    for _ in 0..<(size - size%2) {\n        text = \" \" + text + \" \"\n        counter += 2\n        if counter >= size {\n            return text\n        }\n    }\n    \n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"7\", size: 10) == \"     7     \")"
    },
    {
        "id": 65,
        "code": "\n/// \nfunc f(nums: [Int], index: Int) -> Int {\n    var nums = nums\n    return nums[index] % 42 + nums.remove(at: index) * 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 2, 0, 3, 7], index: 3) == 9)"
    },
    {
        "id": 66
    },
    {
        "id": 67,
        "code": "\n/// \nfunc f(num1: Int, num2: Int, num3: Int) -> String {\n    var nums = [num1, num2, num3]\n    nums.sort()\n    return \"\\(nums[0]),\\(nums[1]),\\(nums[2])\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num1: 6, num2: 8, num3: 8) == \"6,8,8\")"
    },
    {
        "id": 68,
        "code": "import Foundation\n\nfunc f(text: String, pref: String) -> String {\n    if text.hasPrefix(pref) {\n        let n = pref.count\n        let startIndex = text.index(text.startIndex, offsetBy: n)\n        let remainingText = String(text[startIndex...])\n        let remainingParts = remainingText.split(separator: \".\").dropFirst()\n        let prefixParts = text.prefix(n).split(separator: \".\").dropLast()\n        return remainingParts.joined(separator: \".\") + (remainingParts.isEmpty || prefixParts.isEmpty ? \"\" : \".\") + prefixParts.joined(separator: \".\")\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"omeunhwpvr.dq\", pref: \"omeunh\") == \"dq\")"
    },
    {
        "id": 69,
        "code": "extension String: Error {}\n\nfunc f(student_marks: [String : Int], name: String) -> Result<Int, String> {\n    var mutableStudentMarks = student_marks\n    if let value = mutableStudentMarks[name] {\n        mutableStudentMarks[name] = nil\n        return .success(value)\n    }\n    return .failure(\"Name unknown\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(student_marks: [\"882afmfp\" : 56], name: \"6f53p\") == .failure(\"Name unknown\"))"
    },
    {
        "id": 70,
        "code": "\n/// \nfunc f(x: String) -> Int {\n    var a = 0\n    for i in x.split(separator: \" \") {\n        a += i.count * 2\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: \"999893767522480\") == 30)"
    },
    {
        "id": 71
    },
    {
        "id": 72,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    for c in text {\n        if !c.isNumber {\n            return false\n        }\n    }\n    return !text.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"99\") == true)"
    },
    {
        "id": 73,
        "code": "\n\nfunc f(row: String) -> (Int, Int) {\n    let oneCount = row.filter { $0 == \"1\" }.count\n    let zeroCount = row.filter { $0 == \"0\" }.count\n    return (oneCount, zeroCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(row: \"100010010\") == (3, 6))"
    },
    {
        "id": 74,
        "code": "\n/// \nfunc f(lst: [Int], i: Int, n: Int) -> [Int] {\n    var updatedList = lst\n    updatedList.insert(n, at: i)\n    return updatedList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [44, 34, 23, 82, 24, 11, 63, 99], i: 4, n: 15) == [44, 34, 23, 82, 15, 24, 11, 63, 99])"
    },
    {
        "id": 75,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> Int {\n    let ind = array.firstIndex(of: elem)!\n    return ind * 2 + array[array.count - ind - 1] * 3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [-1, 2, 1, -8, 2], elem: 2) == -22)"
    },
    {
        "id": 76,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums.filter { $0 > 0 }\n    if nums.count <= 3 {\n        return nums\n    }\n    nums.reverse()\n    let half = nums.count / 2\n    return Array(nums[..<half]) + [0, 0, 0, 0, 0] + Array(nums[half...])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [10, 3, 2, 2, 6, 0]) == [6, 2, 0, 0, 0, 0, 0, 2, 3, 10])"
    },
    {
        "id": 77,
        "code": "\n\nfunc f(text: String, character: String) -> String {\n    guard let char = character.first, let index = text.lastIndex(of: char) else {\n        return \"\"\n    }\n    let subject = String(text[index...])\n    let count = text.filter { $0 == char }.count\n    return String(repeating: subject, count: count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"h ,lpvvkohh,u\", character: \"i\") == \"\")"
    },
    {
        "id": 78,
        "code": "func f(text: String) -> String {\n    let uppercaseLetters = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    let lowercaseLetters = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    \n    if !text.isEmpty && text == text.uppercased() {\n        let cs = Dictionary(uniqueKeysWithValues: zip(uppercaseLetters, lowercaseLetters))\n        return String(text.map { cs[$0, default: $0] })\n    }\n    return text.lowercased().prefix(3).description\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mTYWLMwbLRVOqNEf.oLsYkZORKE[Ko[{n\") == \"mty\")"
    },
    {
        "id": 79,
        "code": "func f(arr: [Int]) -> String {\n    var arr = arr\n    arr.removeAll()\n    arr.append(1)\n    arr.append(2)\n    arr.append(3)\n    arr.append(4)\n    return arr.map { String($0) }.joined(separator: \",\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(arr: [0, 1, 2, 3, 4]) == \"1,2,3,4\")"
    },
    {
        "id": 80,
        "code": "\n\n/// \nfunc f(s: String) -> String {\n    return String(s.reversed().filter({$0 != \" \"}))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"ab        \") == \"ba\")"
    },
    {
        "id": 81
    },
    {
        "id": 82,
        "code": "\n/// \nfunc f(a: String, b: String, c: String, d: String) -> String {\n    return a.isEmpty ? c : b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"CJU\", b: \"BFS\", c: \"WBYDZPVES\", d: \"Y\") == \"BFS\")"
    },
    {
        "id": 83
    },
    {
        "id": 84,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let arr = text.split(separator: \" \")\n    var result = [String]()\n    for item in arr {\n        if item.hasSuffix(\"day\") {\n            result.append(item + \"y\")\n        } else {\n            result.append(item + \"day\")\n        }\n    }\n    return result.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"nwv mef ofme bdryl\") == \"nwvday mefday ofmeday bdrylday\")"
    },
    {
        "id": 85,
        "code": "func f(n: Int) -> [Double] {\n    let values: [Int: Double] = [0: 3, 1: 4.5, 2: -1]\n    var res = [Double: Int]()\n    \n    for (i, j) in values {\n        if i % n != 2 {\n            res[j] = n / 2\n        }\n    }\n    \n    return res.keys.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 12) == [3, 4.5])"
    },
    {
        "id": 86,
        "code": "\nextension Array: Error {}\n\nfunc f(instagram: [String], imgur: [String], wins: Int) -> Result<String, [String]> {\n    var photos = [instagram, imgur]\n    if instagram == imgur {\n        return .success(\"\\(wins)\")\n    }\n    if wins == 1 {\n        return .failure(photos.popLast()!)\n    } else {\n        photos.reverse()\n        return .failure(photos.popLast()!)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(instagram: [\"sdfs\", \"drcr\", \"2e\"], imgur: [\"sdfs\", \"dr2c\", \"QWERTY\"], wins: 0) == .failure([\"sdfs\", \"drcr\", \"2e\"]))"
    },
    {
        "id": 87,
        "code": "\n/// \nfunc f(nums: [Int]) -> String {\n    var reversedNums = nums.reversed().map { String($0) }\n    return reversedNums.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-1, 9, 3, 1, -2]) == \"-2139-1\")"
    },
    {
        "id": 88,
        "code": "\n/// \nfunc f(s1: String, s2: String) -> String {\n    var result = s2\n    if result.hasSuffix(s1) {\n        result = String(result.dropLast(s1.count))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s1: \"he\", s2: \"hello\") == \"hello\")"
    },
    {
        "id": 89,
        "code": "\n/// \nfunc f(char: String) -> String {\n    if ![\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"].contains(char) {\n        return \"None\"\n    }\n    if [\"A\", \"E\", \"I\", \"O\", \"U\"].contains(char) {\n        return char.lowercased()\n    }\n    return char.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(char: \"o\") == \"O\")"
    },
    {
        "id": 90,
        "code": "\n/// \nfunc f(array: [[Int]]) -> [[Int]] {\n    var returnArray: [[Int]] = []\n    for a in array {\n        returnArray.append(a)\n    }\n    return returnArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [[1, 2, 3], [] as [Int], [1, 2, 3]]) == [[1, 2, 3], [] as [Int], [1, 2, 3]])"
    },
    {
        "id": 91
    },
    {
        "id": 92,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return text.allSatisfy { $0.isASCII }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wW의IV]HDJjhgK[dGIUlVO@Ess$coZkBqu[Ct\") == false)"
    },
    {
        "id": 93,
        "code": "\n/// \nfunc f(n: String) -> String {\n    let length = n.count + 2\n    var revn = Array(n)\n    let result = String(revn)\n    revn.removeAll()\n    return result + String(repeating: \"!\", count: length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: \"iq\") == \"iq!!!!\")"
    },
    {
        "id": 94,
        "code": "\n/// \nfunc f(a: [String : Int], b: [String : Int]) -> [String : Int] {\n    return a.merging(b) { _, new in new }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: [\"w\" : 5, \"wi\" : 10], b: [\"w\" : 3]) == [\"w\" : 3, \"wi\" : 10])"
    },
    {
        "id": 95,
        "code": "\n/// \nfunc f(zoo: [String : String]) -> [String : String] {\n    return Dictionary(uniqueKeysWithValues: zoo.map({ ($1, $0) }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(zoo: [\"AAA\" : \"fr\"]) == [\"fr\" : \"AAA\"])"
    },
    {
        "id": 96,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return !text.contains { $0.isUppercase }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"lunabotics\") == true)"
    },
    {
        "id": 97,
        "code": "\n/// \nfunc f(lst: [Int]) -> Bool {\n    var mutableList = lst\n    mutableList.removeAll()\n    \n    for i in mutableList {\n        if i == 3 {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [2, 0]) == true)"
    },
    {
        "id": 98
    },
    {
        "id": 99
    },
    {
        "id": 100
    },
    {
        "id": 101,
        "code": "\n/// \nfunc f(array: [AnyHashable], i_num: Int, elem: AnyHashable) -> [AnyHashable] {\n    var updatedArray = array\n    updatedArray.insert(elem, at: i_num)\n    return updatedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [-4, 1, 0], i_num: 1, elem: 4) == [-4, 4, 1, 0])"
    },
    {
        "id": 102,
        "code": "\n/// \nfunc f(names: [String], winners: [String]) -> [Int] {\n    var ls: [Int] = names.compactMap { winners.contains($0) ? names.firstIndex(of: $0) : nil }\n    ls.sort(by: >)\n    return ls\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(names: [\"e\", \"f\", \"j\", \"x\", \"r\", \"k\"], winners: [\"a\", \"v\", \"2\", \"im\", \"nb\", \"vj\", \"z\"]) == [] as [Int])"
    },
    {
        "id": 103,
        "code": "\n/// \nfunc f(s: String) -> String {\n    return s.lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"abcDEFGhIJ\") == \"abcdefghij\")"
    },
    {
        "id": 104,
        "code": "\n/// \nfunc f(text: String) -> [String : Int] {\n    var dictionary = [String: Int]()\n    for char in text {\n        dictionary[String(char)] = (dictionary[String(char)] ?? 0) + 1\n    }\n    for key in dictionary.keys {\n        if let count = dictionary[key], count > 1 {\n            dictionary[key] = 1\n        }\n    }\n    return dictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a\") == [\"a\" : 1])"
    },
    {
        "id": 105
    },
    {
        "id": 106,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var updatedNums = nums\n    for i in 0..<updatedNums.count {\n        updatedNums.insert(updatedNums[i]*2, at: i)\n    }\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 8, -2, 9, 3, 3]) == [4, 4, 4, 4, 4, 4, 2, 8, -2, 9, 3, 3])"
    },
    {
        "id": 107,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var result = [Character]()\n    \n    for char in text {\n        if !char.isASCII {\n            return \"False\"\n        } else if char.isLetter {\n            result.append(Character(char.uppercased()))\n        } else {\n            result.append(char)\n        }\n    }\n    \n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ua6hajq\") == \"UA6HAJQ\")"
    },
    {
        "id": 108
    },
    {
        "id": 109,
        "code": "\n/// \nfunc f(nums: [Int], spot: Int, idx: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.insert(idx, at: spot)\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 0, 1, 1], spot: 0, idx: 9) == [9, 1, 0, 1, 1])"
    },
    {
        "id": 110,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var a = [\"\"]\n    var b = \"\"\n    for i in text {\n        if !i.isWhitespace {\n            a.append(b)\n            b = \"\"\n        } else {\n            b += String(i)\n        }\n    }\n    return a.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"       \") == 1)"
    },
    {
        "id": 111,
        "code": "\n/// \nfunc f(marks: [String : Int]) -> (Int, Int) {\n    var highest = 0\n    var lowest = 100\n    for value in marks.values {\n        if value > highest {\n            highest = value\n        }\n        if value < lowest {\n            lowest = value\n        }\n    }\n    return (highest, lowest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(marks: [\"x\" : 67, \"v\" : 89, \"\" : 4, \"alij\" : 11, \"kgfsd\" : 72, \"yafby\" : 83]) == (89, 4))"
    },
    {
        "id": 112
    },
    {
        "id": 113,
        "code": "\n/// \nfunc f(line: String) -> String {\n    var count = 0\n    var a: [Character] = []\n    \n    for i in line.indices {\n        count += 1\n        if count % 2 == 0 {\n            a.append(line[i].isLetter ? Character(line[i].lowercased() == String(line[i]) ? line[i].uppercased() : line[i].lowercased()) : line[i])\n        } else {\n            a.append(line[i])\n        }\n    }\n    \n    return String(a)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(line: \"987yhNSHAshd 93275yrgSgbgSshfbsfB\") == \"987YhnShAShD 93275yRgsgBgssHfBsFB\")"
    },
    {
        "id": 114,
        "code": "import Foundation\n\nfunc f(text: String, sep: String) -> [String] {\n    let components = text.components(separatedBy: sep)\n    if components.count <= 3 {\n        return components\n    } else {\n        let lastIndex = components.count - 1\n        let secondLastIndex = components.count - 2\n        let remaining = components[0..<secondLastIndex].joined(separator: sep)\n        return [remaining, components[secondLastIndex], components[lastIndex]]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a-.-.b\", sep: \"-.\") == [\"a\", \"\", \"b\"])"
    },
    {
        "id": 115
    },
    {
        "id": 116,
        "code": "\n\n/// \nfunc f(d: [Int : Int], count: Int) -> [Int : Int] {\n    var dict = d\n    for _ in 0..<count {\n        if dict.isEmpty {\n            break\n        }\n        dict.removeValue(forKey: dict.keys.first!)\n    }\n    return dict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [:] as [Int : Int], count: 200) == [:] as [Int : Int])"
    },
    {
        "id": 117,
        "code": "\n/// \nfunc f(numbers: String) -> Int {\n    for i in 0..<numbers.count {\n        if numbers.filter({$0 == \"3\"}).count > 1 {\n            return i\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: \"23157\") == -1)"
    },
    {
        "id": 118,
        "code": "import Foundation\n\nfunc f(text: String, chars: String) -> String {\n    var text = text\n    let numApplies = 2\n    var extraChars = \"\"\n    \n    for _ in 0..<numApplies {\n        extraChars += chars\n        text = text.replacingOccurrences(of: extraChars, with: \"\")\n    }\n    \n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"zbzquiuqnmfkx\", chars: \"mk\") == \"zbzquiuqnmfkx\")"
    },
    {
        "id": 119,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var result = \"\"\n    for i in 0..<text.count {\n        if i % 2 == 0 {\n            result += String(text[text.index(text.startIndex, offsetBy: i)]).uppercased()\n        } else {\n            result += String(text[text.index(text.startIndex, offsetBy: i)])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"vsnlygltaw\") == \"VsNlYgLtAw\")"
    },
    {
        "id": 120,
        "code": "\n/// \nfunc f(countries: [String : String]) -> [String : [String]] {\n    var language_country = [String: [String]]()\n    \n    for (country, language) in countries {\n        if language_country[language] == nil {\n            language_country[language] = []\n        }\n        language_country[language]?.append(country)\n    }\n    \n    return language_country\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(countries: [:] as [String : String]) == [:] as [String : [String]])"
    },
    {
        "id": 121,
        "code": "\n/// \nfunc f(s: String) -> String {\n    let nums = s.filter { $0.isNumber }\n    if nums.isEmpty {\n        return \"none\"\n    }\n    let numbers = nums.split(separator: \",\").compactMap { Int(String($0)) }\n    guard let maxNum = numbers.max() else {\n        return \"none\"\n    }\n    return String(maxNum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"01,001\") == \"1001\")"
    },
    {
        "id": 122,
        "code": "import Foundation\n\nfunc f(string: String) -> String {\n    if !string.hasPrefix(\"Nuva\") {\n        return \"no\"\n    } else {\n        return string.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"Nuva?dlfuyjys\") == \"Nuva?dlfuyjys\")"
    },
    {
        "id": 123,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> [Int] {\n    var newArray = array\n    for (idx, e) in newArray.enumerated() {\n        if e > elem && newArray[max(idx - 1, 0)] < elem {\n            newArray.insert(elem, at: idx)\n        }\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 3, 5, 8], elem: 6) == [1, 2, 3, 5, 6, 8])"
    },
    {
        "id": 124,
        "code": "import Foundation\n\nfunc f(txt: String, sep: String, sep_count: Int) -> String {\n    var o = \"\"\n    var txt = txt\n    var sep_count = sep_count\n    \n    while sep_count > 0 && txt.contains(sep) {\n        if let range = txt.range(of: sep, options: .backwards) {\n            o += txt[..<range.lowerBound] + sep\n            txt = String(txt[range.upperBound...])\n        }\n        sep_count -= 1\n    }\n    return o + txt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: \"i like you\", sep: \" \", sep_count: -1) == \"i like you\")"
    },
    {
        "id": 125
    },
    {
        "id": 126,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    let s = text.split(separator: \"o\", maxSplits: 1, omittingEmptySubsequences: true)\n    let div = s.count == 1 ? \"-\" : s[0]\n    let div2 = s.count == 1 ? \"-\" : s[1]\n    return s.count == 1 ? \"-\" + s[0] : s[0] + \"o\" + s[0] + \"o\" + s[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"kkxkxxfck\") == \"-kkxkxxfck\")"
    },
    {
        "id": 127,
        "code": "func f(text: String) -> Int {\n    let s = text.split(separator: \"\\n\", omittingEmptySubsequences: false)\n    return s.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"145\\n\\n12fjkjg\") == 3)"
    },
    {
        "id": 128,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var odd = \"\"\n    var even = \"\"\n    for (i, c) in text.enumerated() {\n        if i % 2 == 0 {\n            even.append(c)\n        } else {\n            odd.append(c)\n        }\n    }\n    return even + odd.lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Mammoth\") == \"Mmohamt\")"
    },
    {
        "id": 129
    },
    {
        "id": 130
    },
    {
        "id": 131
    },
    {
        "id": 132
    },
    {
        "id": 133,
        "code": "\n\nfunc f(nums: [Int], elements: [Int]) -> [Int] {\n    var nums = nums\n    for _ in elements {\n        nums.removeLast()\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [7, 1, 2, 6, 0, 2], elements: [9, 0, 3]) == [7, 1, 2])"
    },
    {
        "id": 134,
        "code": "\n/// \nfunc f(n: Int) -> String {\n    var t = 0\n    var b = \"\"\n    let digits = String(n).compactMap { Int(String($0)) }\n    for d in digits {\n        if d == 0 {\n            t += 1\n        } else {\n            break\n        }\n    }\n    for _ in 0..<t {\n        b += \"\\(1)0\\(4)\"\n    }\n    b += String(n)\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 372359) == \"372359\")"
    },
    {
        "id": 135
    },
    {
        "id": 136
    },
    {
        "id": 137,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    var count = 0\n    for i in 0..<nums.count {\n        if nums.isEmpty {\n            break\n        }\n        if count % 2 == 0 {\n            nums.removeLast()\n        } else {\n            nums.removeFirst()\n        }\n        count += 1\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 2, 0, 0, 2, 3]) == [] as [Int])"
    },
    {
        "id": 138,
        "code": "func f(text: String, chars: String) -> String {\n    var textArray = Array(text)\n    let listchars = Array(chars)\n    let first = listchars[0]\n    \n    for i in 1..<listchars.count {\n        if let index = textArray.firstIndex(of: listchars[i]) {\n            textArray[index] = listchars[i]\n        }\n    }\n    \n    return String(textArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"tflb omn rtt\", chars: \"m\") == \"tflb omn rtt\")"
    },
    {
        "id": 139,
        "code": "\nextension Array: Error {}\n\nfunc f(first: [Int], second: [Int]) -> Result<String, [Int]> {\n    if first.count < 10 || second.count < 10 {\n        return .success(\"no\")\n    }\n    for i in 0..<5 {\n        if first[i] != second[i] {\n            return .success(\"no\")\n        }\n    }\n    var mutableFirst = first\n    mutableFirst.append(contentsOf: second)\n    return .failure(mutableFirst)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(first: [1, 2, 1], second: [1, 1, 2]) == .success(\"no\"))"
    },
    {
        "id": 140,
        "code": "func f(st: String) -> String {\n    let lowercasedSt = st.lowercased()\n    \n    if let iIndex = lowercasedSt.lastIndex(of: \"i\") {\n        if let hIndex = lowercasedSt[..<iIndex].lastIndex(of: \"h\") {\n            if lowercasedSt.distance(from: hIndex, to: iIndex) >= 0 {\n                return \"Hey\"\n            }\n        }\n    }\n    \n    return \"Hi\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(st: \"Hi there\") == \"Hey\")"
    },
    {
        "id": 141,
        "code": "\n/// \nfunc f(li: [String]) -> [Int] {\n    return li.map({item in li.filter({$0 == item}).count})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(li: [\"k\", \"x\", \"c\", \"x\", \"x\", \"b\", \"l\", \"f\", \"r\", \"n\", \"g\"]) == [1, 3, 1, 3, 3, 1, 1, 1, 1, 1, 1])"
    },
    {
        "id": 142,
        "code": "\n/// \nfunc f(x: String) -> String {\n    if x == x.lowercased() {\n        return x\n    } else {\n        return String(x.reversed())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: \"ykdfhp\") == \"ykdfhp\")"
    },
    {
        "id": 143,
        "code": "\n/// \nfunc f(s: String, n: String) -> Bool {\n    return s.lowercased() == n.lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"daaX\", n: \"daaX\") == true)"
    },
    {
        "id": 144,
        "code": "\n/// \nfunc f(vectors: [[Int]]) -> [[Int]] {\n    var sortedVecs: [[Int]] = []\n    for var vec in vectors {\n        vec.sort()\n        sortedVecs.append(vec)\n    }\n    return sortedVecs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(vectors: [] as [[Int]]) == [] as [[Int]])"
    },
    {
        "id": 145,
        "code": "func f(price: Double, product: String) -> Double {\n    var price = price\n    var inventory = [\"olives\", \"key\", \"orange\"]\n    \n    if !inventory.contains(product) {\n        return price\n    } else {\n        price *= 0.85\n        if let index = inventory.firstIndex(of: product) {\n            inventory.remove(at: index)\n        }\n    }\n    \n    return price\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(price: 8.5, product: \"grapes\") == 8.5)"
    },
    {
        "id": 146,
        "code": "\n/// \nfunc f(single_digit: Int) -> [Int] {\n    var result: [Int] = []\n    for c in 1..<11 {\n        if c != single_digit {\n            result.append(c)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(single_digit: 5) == [1, 2, 3, 4, 6, 7, 8, 9, 10])"
    },
    {
        "id": 147,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    let middle = nums.count / 2\n    return Array(nums[middle..<nums.count]) + Array(nums[0..<middle])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1, 1]) == [1, 1, 1])"
    },
    {
        "id": 148,
        "code": "func f(forest: String, animal: String) -> String {\n    guard let index = forest.firstIndex(of: Character(animal)) else {\n        return forest\n    }\n    \n    var result = Array(forest)\n    var currentIndex = forest.distance(from: forest.startIndex, to: index)\n    \n    while currentIndex < forest.count - 1 {\n        result[currentIndex] = result[currentIndex + 1]\n        currentIndex += 1\n    }\n    \n    if currentIndex == forest.count - 1 {\n        result[currentIndex] = \"-\"\n    }\n    \n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(forest: \"2imo 12 tfiqr.\", animal: \"m\") == \"2io 12 tfiqr.-\")"
    },
    {
        "id": 149
    },
    {
        "id": 150,
        "code": "\n/// \nfunc f(numbers: [Int], index: Int) -> [Int] {\n    var updatedNumbers = numbers\n    var newIndex = index\n    for n in numbers[index...] {\n        updatedNumbers.insert(n, at: newIndex)\n        newIndex += 1\n    }\n    return Array(updatedNumbers.prefix(newIndex))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [-2, 4, -4], index: 0) == [-2, 4, -4])"
    },
    {
        "id": 151
    },
    {
        "id": 152,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> Int {\n    let upperCaseLetters = CharacterSet.uppercaseLetters\n    return text.unicodeScalars.filter { upperCaseLetters.contains($0) }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"AAAAAAAAAAAAAAAAAAAA\") == 20)"
    },
    {
        "id": 153,
        "code": "\n/// \nfunc f(text: String, suffix: String, num: Int) -> Bool {\n    let strNum = String(num)\n    return text.hasSuffix(suffix + strNum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"friends and love\", suffix: \"and\", num: 3) == false)"
    },
    {
        "id": 154,
        "code": "\n/// \nfunc f(s: String, c: String) -> String {\n    var splitArray = s.split(separator: \" \")\n    splitArray.reverse()\n    return (c + \"  \") + splitArray.joined(separator: \"  \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"Hello There\", c: \"*\") == \"*  There  Hello\")"
    },
    {
        "id": 155,
        "code": "\n/// \nfunc f(ip: String, n: Int) -> String {\n    var i = 0\n    var out = \"\"\n    for c in ip {\n        if i == n {\n            out += \"\\n\"\n            i = 0\n        }\n        i += 1\n        out += String(c)\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ip: \"dskjs hjcdjnxhjicnn\", n: 4) == \"dskj\\ns hj\\ncdjn\\nxhji\\ncnn\")"
    },
    {
        "id": 156,
        "code": "func f(text: String, limit: Int, char: Character) -> String {\n    if limit < text.count {\n        return String(text.prefix(limit))\n    }\n    \n    var paddedText = text\n    for _ in 0..<(limit - text.count) {\n        paddedText.append(char)\n    }\n    \n    return paddedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"tqzym\", limit: 5, char: \"c\") == \"tqzym\")"
    },
    {
        "id": 157,
        "code": "\n/// \nfunc f(phrase: String) -> Int {\n    var ans = 0\n    for word in phrase.split(separator: \" \") {\n        for char in word {\n            if char == \"0\" {\n                ans += 1\n            }\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(phrase: \"aboba 212 has 0 digits\") == 1)"
    },
    {
        "id": 158,
        "code": "\n/// \nfunc f(arr: [Int]) -> [Int] {\n    let n = arr.filter { $0 % 2 == 0 }\n    var m = n + arr\n    for i in m {\n        if let index = m.firstIndex(of: i), index >= n.count {\n            m.removeAll(where: { $0 == i })\n        }\n    }\n    return m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(arr: [3, 6, 4, -2, 5]) == [6, 4, -2, 6, 4, -2])"
    },
    {
        "id": 159,
        "code": "\n/// \nfunc f(st: String) -> String {\n    var swapped = \"\"\n    for ch in st.reversed() {\n        swapped += String(ch).uppercased() == String(ch) ? String(ch).lowercased() : String(ch).uppercased()\n    }\n    return swapped\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(st: \"RTiGM\") == \"mgItr\")"
    },
    {
        "id": 160
    },
    {
        "id": 161,
        "code": "func f(text: String, value: String) -> String {\n    let parts = text.split(separator: Character(value), maxSplits: 1)\n    return parts.count > 1 ? String(parts[1]) + String(parts[0]) : \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"difkj rinpx\", value: \"k\") == \"j rinpxdif\")"
    },
    {
        "id": 162,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var result = \"\"\n    for char in text {\n        if char.isLetter || char.isNumber {\n            result += String(char).uppercased()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"с bishop.Swift\") == \"СBISHOPSWIFT\")"
    },
    {
        "id": 163,
        "code": "\n/// \nfunc f(text: String, space_symbol: String, size: Int) -> String {\n    let spaces = String(repeating: space_symbol, count: max(size - text.count, 0))\n    return text + spaces\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"w\", space_symbol: \"))\", size: 7) == \"w))))))))))))\")"
    },
    {
        "id": 164,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    return Array(sortedList.prefix(3))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [5, 8, 1, 3, 0]) == [0, 1, 3])"
    },
    {
        "id": 165,
        "code": "\n/// \nfunc f(text: String, lower: Int, upper: Int) -> Bool {\n    return text[text.index(text.startIndex, offsetBy: lower)..<text.index(text.startIndex, offsetBy: upper)].allSatisfy { $0.isASCII }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"=xtanp|sugv?z\", lower: 3, upper: 6) == true)"
    },
    {
        "id": 166,
        "code": "\n/// \nfunc f(graph: [String : [String : String]]) -> [String : [String : String]] {\n    var newGraph: [String: [String: String]] = [:]\n    \n    for (key, value) in graph {\n        newGraph[key] = [:]\n        for subkey in value.keys {\n            newGraph[key]?[subkey] = \"\"\n        }\n    }\n    \n    return newGraph\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(graph: [:] as [String : [String : String]]) == [:] as [String : [String : String]])"
    },
    {
        "id": 167
    },
    {
        "id": 168,
        "code": "\n/// \nfunc f(text: String, new_value: String, index: Int) -> String {\n    var key = [Character: Character]()\n    key[text[text.index(text.startIndex, offsetBy: index)]] = new_value[new_value.startIndex]\n    let result = String(text.map { key[$0] ?? $0 })\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"spain\", new_value: \"b\", index: 4) == \"spaib\")"
    },
    {
        "id": 169,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    var ls = Array(text)\n    let total = (text.count - 1) * 2\n    for i in 1...total {\n        if i % 2 == 1 {\n            ls.append(\"+\")\n        } else {\n            ls.insert(\"+\", at: 0)\n        }\n    }\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"taole\") == \"++++taole++++\")"
    },
    {
        "id": 170,
        "code": "\n/// \nfunc f(nums: [Int], number: Int) -> Int {\n    return nums.filter{$0 == number}.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [12, 0, 13, 4, 12], number: 12) == 2)"
    },
    {
        "id": 171,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    let count = nums.count / 2\n    for _ in 0..<count {\n        nums.removeFirst()\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 4, 1, 2, 3]) == [1, 2, 3])"
    },
    {
        "id": 172,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var newArray = array.filter { $0 >= 0 }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 173,
        "code": "\n/// \nfunc f(list_x: [Int]) -> [Int] {\n    var newList = [Int]()\n    var mutableList = list_x\n    for _ in 0..<list_x.count {\n        newList.append(mutableList.removeLast())\n    }\n    return newList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(list_x: [5, 8, 6, 8, 4]) == [4, 8, 6, 8, 5])"
    },
    {
        "id": 174
    },
    {
        "id": 175
    },
    {
        "id": 176,
        "code": "import Foundation\n\nfunc f(text: String, to_place: String) -> String {\n    if let range = text.range(of: to_place) {\n        let afterPlace = text[..<range.upperBound]\n        let beforePlace = text[range.upperBound...]\n        return String(afterPlace + beforePlace)\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"some text\", to_place: \"some\") == \"some text\")"
    },
    {
        "id": 177,
        "code": "func f(text: String) -> String {\n    var textArray = Array(text)\n    for i in 0..<textArray.count {\n        if i % 2 == 1 {\n            let char = String(textArray[i])\n            textArray[i] = char.uppercased() == char ? char.lowercased().first! : char.uppercased().first!\n        }\n    }\n    return String(textArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Hey DUdE THis $nd^ &*&this@#\") == \"HEy Dude tHIs $Nd^ &*&tHiS@#\")"
    },
    {
        "id": 178,
        "code": "\n/// \nfunc f(array: [Int], n: Int) -> [Int] {\n    return Array(array[n...])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [0, 0, 1, 2, 2, 2, 2], n: 4) == [2, 2, 2])"
    },
    {
        "id": 179
    },
    {
        "id": 180,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    var a = -1\n    var b = Array(nums[1...])\n    while a <= b[0] {\n        nums.removeAll(where: { $0 == b[0] })\n        a = 0\n        b = Array(b.dropFirst())\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-1, 5, 3, -2, -6, 8, 8]) == [-1, -2, -6, 8, 8])"
    },
    {
        "id": 181,
        "code": "\n\n/// \nfunc f(s: String) -> (String, Int) {\n    var count = 0\n    var digits = \"\"\n    for c in s {\n        if c.isNumber {\n            count += 1\n            digits += String(c)\n        }\n    }\n    return (digits, count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"qwfasgahh329kn12a23\") == (\"3291223\", 7))"
    },
    {
        "id": 182
    },
    {
        "id": 183,
        "code": "\n/// \nfunc f(text: String) -> [String] {\n    let ls = text.split(separator: \" \").map { String($0) }\n    let lines = ls.enumerated().filter { $0.offset % 3 == 0 }.map { $0.element }\n    var res: [String] = []\n    \n    for i in 0..<2 {\n        let ln = ls.enumerated().filter { ($0.offset - 1) % 3 == 0 }.map { $0.element }\n        if 3 * i + 1 < ln.count {\n            res.append(ln[3 * i..<3 * (i + 1)].joined(separator: \" \"))\n        }\n    }\n    \n    return lines + res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"echo hello!!! nice!\") == [\"echo\"])"
    },
    {
        "id": 184,
        "code": "\n/// \nfunc f(digits: [Int]) -> [Int] {\n    var digits = digits\n    digits.reverse()\n    if digits.count < 2 {\n        return digits\n    }\n    \n    for i in stride(from: 0, to: digits.count, by: 2) {\n        if i + 1 < digits.count {\n            digits.swapAt(i, i + 1)\n        }\n    }\n    \n    return digits\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(digits: [1, 2]) == [1, 2])"
    },
    {
        "id": 185,
        "code": "\n/// \nfunc f(L: [Int]) -> [Int] {\n    var result = L\n    let N = result.count\n    for k in 1...(N/2) {\n        var i = k - 1\n        var j = N - k\n        while i < j {\n            // swap elements:\n            (result[i], result[j]) = (result[j], result[i])\n            // update i, j:\n            i += 1\n            j -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(L: [16, 14, 12, 7, 9, 11]) == [11, 14, 7, 12, 9, 16])"
    },
    {
        "id": 186,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    return text.split(separator: \" \").map { String($0).trimmingCharacters(in: CharacterSet.whitespaces) }.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"pvtso\") == \"pvtso\")"
    },
    {
        "id": 187,
        "code": "import Foundation\n\nfunc f(d: [Int : Int], index: Int) -> Int {\n    var d = d\n    let length = d.count\n    let idx = index % length\n    let v = d.popFirst()!.value\n    for _ in 0..<idx {\n        d.popFirst()\n    }\n    return v\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [27 : 39], index: 1) == 39)"
    },
    {
        "id": 188,
        "code": "\n/// \nfunc f(strings: [String]) -> [String] {\n    var newStrings: [String] = []\n    for string in strings {\n        let firstTwo = String(string.prefix(2))\n        if firstTwo.hasPrefix(\"a\") || firstTwo.hasPrefix(\"p\") {\n            newStrings.append(firstTwo)\n        }\n    }\n    \n    return newStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strings: [\"a\", \"b\", \"car\", \"d\"]) == [\"a\"])"
    },
    {
        "id": 189,
        "code": "\nimport Foundation\n\nfunc f(out: String, mapping: [String : [String]]) -> String {\n    var out = out\n    for key in mapping.keys {\n        let value = mapping[key]?.first ?? \"\"\n        let replacement = String(value.reversed())\n        out = out.replacingOccurrences(of: \"{\" + key + \"}\", with: replacement)\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(out: \"{{{{}}}}\", mapping: [:] as [String : [String]]) == \"{{{{}}}}\")"
    },
    {
        "id": 190,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var short = \"\"\n    for c in text {\n        if c.isLowercase {\n            short += String(c)\n        }\n    }\n    return short\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"980jio80jic kld094398IIl \") == \"jiojickldl\")"
    },
    {
        "id": 191,
        "code": "\n/// \nfunc f(string: String) -> Bool {\n    return string == string.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"Ohno\") == false)"
    },
    {
        "id": 192,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    var output = text\n    while output.hasSuffix(suffix) {\n        output = String(output.dropLast(suffix.count))\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"!klcd!ma:ri\", suffix: \"!\") == \"!klcd!ma:ri\")"
    },
    {
        "id": 193,
        "code": "\nimport Foundation\n\nfunc f(string: String) -> String {\n    let count = string.filter { $0 == \":\" }.count\n    let range = string.range(of: \":\")!\n    let substring = string.replacingOccurrences(of: \":\", with: \"\", options: .backwards, range: range)\n    return String(substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"1::1\") == \"1:1\")"
    },
    {
        "id": 194,
        "code": "\n/// \nfunc f(matr: [[Int]], insert_loc: Int) -> [[Int]] {\n    var updatedMatrix = matr\n    updatedMatrix.insert([], at: insert_loc)\n    return updatedMatrix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(matr: [[5, 6, 2, 3], [1, 9, 5, 6]], insert_loc: 0) == [[] as [Int], [5, 6, 2, 3], [1, 9, 5, 6]])"
    },
    {
        "id": 195,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    var text = text\n    for p in [\"acs\", \"asp\", \"scn\"] {\n        if text.hasPrefix(p) {\n            text.removeFirst(p.count)\n        }\n        text += \" \"\n    }\n    if text.hasPrefix(\" \") {\n        text.removeFirst()\n    }\n    return String(text.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ilfdoirwirmtoibsac\") == \"ilfdoirwirmtoibsac  \")"
    },
    {
        "id": 196,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    var modifiedText = text.replacingOccurrences(of: \" x\", with: \" x.\")\n    if modifiedText.capitalized == modifiedText {\n        return \"correct\"\n    }\n    modifiedText = modifiedText.replacingOccurrences(of: \" x.\", with: \" x\")\n    return \"mixed\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"398 Is A Poor Year To Sow\") == \"correct\")"
    },
    {
        "id": 197,
        "code": "func f(temp: Int, timeLimit: Int) -> String {\n    let s = timeLimit / temp\n    let e = timeLimit % temp\n    return [String(\"\\(e) oC\"), String(\"\\(s) \\(e)\")][s > 1 ? 1 : 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(temp: 1, timeLimit: 1234567890) == \"1234567890 0\")"
    },
    {
        "id": 198,
        "code": "\n/// \nfunc f(text: String, strip_chars: String) -> String {\n    return String(text.reversed().drop(while: { strip_chars.contains($0) }).reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"tcmfsmj\", strip_chars: \"cfj\") == \"tcmfsm\")"
    },
    {
        "id": 199,
        "code": "import Foundation\n\nfunc f(s: String, char: String) -> String {\n    let base = String(repeating: char, count: s.filter { $0 == Character(char) }.count + 1)\n    if s.hasSuffix(base) {\n        return String(s.dropLast(base.count))\n    } else {\n        return s\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"mnmnj krupa...##!@#!@#$$@##\", char: \"@\") == \"mnmnj krupa...##!@#!@#$$@##\")"
    },
    {
        "id": 200,
        "code": "\n/// \nfunc f(text: String, value: String) -> String {\n    var length = text.count\n    var index = 0\n    var result = value\n    while length > 0 {\n        result = String(text[text.index(text.startIndex, offsetBy: index)]) + result\n        length -= 1\n        index += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"jao mt\", value: \"house\") == \"tm oajhouse\")"
    },
    {
        "id": 201,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var chars: [Character] = []\n    for c in text {\n        if c.isNumber {\n            chars.append(c)\n        }\n    }\n    return String(chars.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"--4yrw 251-//4 6p\") == \"641524\")"
    },
    {
        "id": 202,
        "code": "\n\nfunc f(array: [Int], lst: [Int]) -> [Int] {\n    var newArray = array\n    newArray.append(contentsOf: lst)\n    return newArray.filter { $0 >= 10 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [2, 15], lst: [15, 1]) == [15, 15])"
    },
    {
        "id": 203
    },
    {
        "id": 204,
        "code": "func f(name: String) -> [String] {\n    let firstChar = String(name[name.startIndex])\n    let secondChar = String(name[name.index(after: name.startIndex)])\n    return [firstChar, secondChar]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(name: \"master. \") == [\"m\", \"a\"])"
    },
    {
        "id": 205,
        "code": "\n/// \nfunc f(a: String) -> String {\n    var a = a\n    for _ in 0..<10 {\n        for j in a.indices {\n            if a[j] != \"#\" {\n                a = String(a[j...])\n                break\n            } else if j == a.index(before: a.endIndex) {\n                a = \"\"\n                break\n            }\n        }\n    }\n    while a.last == \"#\" {\n        a = String(a.dropLast())\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"##fiu##nk#he###wumun##\") == \"fiu##nk#he###wumun\")"
    },
    {
        "id": 206,
        "code": "\n/// \nfunc f(a: String) -> String {\n    return a.split(separator: \" \").joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \" h e l l o   w o r l d! \") == \"h e l l o w o r l d!\")"
    },
    {
        "id": 207,
        "code": "\n/// \nfunc f(commands: [[String : Int]]) -> [String : Int] {\n    var d: [String: Int] = [:]\n    for c in commands {\n        for (key, value) in c {\n            d[key] = value\n        }\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(commands: [[\"brown\" : 2], [\"blue\" : 5], [\"bright\" : 4]]) == [\"brown\" : 2, \"blue\" : 5, \"bright\" : 4])"
    },
    {
        "id": 208,
        "code": "\n/// \nfunc f(items: [String]) -> [String] {\n    var result: [String] = []\n    for item in items {\n        for d in item {\n            if !d.isNumber {\n                result.append(String(d))\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(items: [\"123\", \"cat\", \"d dee\"]) == [\"c\", \"a\", \"t\", \"d\", \" \", \"d\", \"e\", \"e\"])"
    },
    {
        "id": 209
    },
    {
        "id": 210,
        "code": "\n/// \nfunc f(n: Int, m: Int, num: Int) -> Int {\n    var x_list = Array(n...m)\n    var j = 0\n    while true {\n        j = (j + num) % x_list.count\n        if x_list[j] % 2 == 0 {\n            return x_list[j]\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 46, m: 48, num: 21) == 46)"
    },
    {
        "id": 211,
        "code": "\n/// \nfunc f(s: String) -> Int {\n    var count = 0\n    for char in s {\n        if s.lastIndex(of: char) != s.firstIndex(of: char) {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"abca dea ead\") == 10)"
    },
    {
        "id": 212,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var result = nums\n    for _ in 0..<(nums.count - 1) {\n        result.reverse()\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, -9, 7, 2, 6, -3, 3]) == [1, -9, 7, 2, 6, -3, 3])"
    },
    {
        "id": 213,
        "code": "\nimport Foundation\n\nfunc f(s: String) -> String {\n    return s.replacingOccurrences(of: \"(\", with: \"[\").replacingOccurrences(of: \")\", with: \"]\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"(ac)\") == \"[ac]\")"
    },
    {
        "id": 214
    },
    {
        "id": 215,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var new_text = text\n    while new_text.count > 1 && new_text.first == new_text.last {\n        new_text = String(new_text.dropFirst().dropLast())\n    }\n    return new_text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \")\") == \")\")"
    },
    {
        "id": 216,
        "code": "\n/// \nfunc f(letters: String) -> Int {\n    var count = 0\n    for l in letters {\n        if l.isNumber {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(letters: \"dp ef1 gh2\") == 2)"
    },
    {
        "id": 217,
        "code": "import Foundation\n\nfunc f(string: String) -> String {\n    if string.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) == nil {\n        return \"ascii encoded is allowed for this language\"\n    }\n    return \"more than ASCII\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"Str zahrnuje anglo-ameriæske vasi piscina and kuca!\") == \"more than ASCII\")"
    },
    {
        "id": 218
    },
    {
        "id": 219,
        "code": "func f(s1: String, s2: String) -> Bool {\n    var s1 = s1\n    let s2Chars = Array(s2)\n    for _ in 0..<(s2.count + s1.count) {\n        s1.append(s1.removeFirst())\n        if s1.contains(where: { s2Chars.contains($0) }) {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s1: \"Hello\", s2: \")\") == false)"
    },
    {
        "id": 220,
        "code": "\n/// \nfunc f(text: String, m: Int, n: Int) -> String {\n    var text = text + text.prefix(m) + text.suffix(text.count - n)\n    var result = \"\"\n    for i in n..<(text.count - m) {\n        result = String(text[text.index(text.startIndex, offsetBy: i)]) + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abcdefgabc\", m: 1, n: 2) == \"bagfedcacbagfedc\")"
    },
    {
        "id": 221
    },
    {
        "id": 222
    },
    {
        "id": 223,
        "code": "\n/// \nfunc f(array: [Int], target: Int) -> Int {\n    var count = 0, i = 1\n    for j in 1..<array.count {\n        if array[j] > array[j - 1] && array[j] <= target {\n            count += i\n        } else if array[j] <= array[j - 1] {\n            i = 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, -1, 4], target: 2) == 1)"
    },
    {
        "id": 224,
        "code": "func f(array: [String], value: Int) -> [String : Int] {\n    var reversedArray = Array(array.reversed())\n    _ = reversedArray.popLast()\n    var odd: [[String: Int]] = []\n    while !reversedArray.isEmpty {\n        var tmp: [String: Int] = [:]\n        if let last = reversedArray.popLast() {\n            tmp[last] = value\n            odd.append(tmp)\n        }\n    }\n    \n    var result: [String: Int] = [:]\n    while !odd.isEmpty {\n        if let dict = odd.popLast() {\n            for (key, value) in dict {\n                result[key] = value\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [\"23\"], value: 123) == [:] as [String : Int])"
    },
    {
        "id": 225
    },
    {
        "id": 226,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var result = nums\n    for i in 0..<result.count {\n        if result[i] % 3 == 0 {\n            result.append(result[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 3]) == [1, 3, 3])"
    },
    {
        "id": 227,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var text = text.lowercased()\n    let head = text.prefix(1).uppercased()\n    let tail = text.dropFirst()\n    return head + tail\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Manolo\") == \"Manolo\")"
    },
    {
        "id": 228,
        "code": "func f(text: String, splitter: String) -> String {\n    return text.lowercased().split(separator: \" \").joined(separator: splitter)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"LlTHH sAfLAPkPhtsWP\", splitter: \"#\") == \"llthh#saflapkphtswp\")"
    },
    {
        "id": 229
    },
    {
        "id": 230,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var result = \"\"\n    var i = text.count - 1\n    while i >= 0 {\n        let index = text.index(text.startIndex, offsetBy: i)\n        let c = text[index]\n        if c.isLetter {\n            result.append(c)\n        }\n        i -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"102x0zoq\") == \"qozx\")"
    },
    {
        "id": 231,
        "code": "\n/// \nfunc f(years: [Int]) -> Int {\n    let a10 = years.filter { $0 <= 1900 }.count\n    let a90 = years.filter { $0 > 1910 }.count\n    \n    if a10 > 3 {\n        return 3\n    } else if a90 > 3 {\n        return 1\n    } else {\n        return 2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(years: [1872, 1995, 1945]) == 2)"
    },
    {
        "id": 232,
        "code": "\n/// \nfunc f(text: String, changes: String) -> String {\n    var result = \"\"\n    var count = 0\n    var changesArray = Array(changes)\n    \n    for char in text {\n        result += char == \"e\" ? String(char) : String(changesArray[count % changesArray.count])\n        count += (char != \"e\" ? 1 : 0)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"fssnvd\", changes: \"yes\") == \"yesyes\")"
    },
    {
        "id": 233,
        "code": "\n\n/// The function in Swift is similar to the original Python function, but Swift's `Array` type does not have the `insert` method, so we have to use `insert(contentsOf:at:)` instead.\nfunc f(xs: [Int]) -> [Int] {\n    var new_xs = xs\n    for idx in stride(from: -new_xs.count , through: -1, by: -1) {\n        new_xs.insert(contentsOf: [new_xs.removeFirst()], at: idx)\n    }\n    return new_xs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(xs: [1, 2, 3]) == [1, 2, 3])"
    },
    {
        "id": 234,
        "code": "func f(text: String, char: String) -> Int {\n    var position = text.count\n    if let character = char.first, text.contains(character) {\n        if let index = text.firstIndex(of: character) {\n            position = text.distance(from: text.startIndex, to: index)\n            if position > 1 {\n                position = (position + 1) % text.count\n            }\n        }\n    }\n    return position\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wduhzxlfk\", char: \"w\") == 0)"
    },
    {
        "id": 235,
        "code": "func f(array: [String], arr: [String]) -> [String] {\n    var result: [String] = []\n    for s in arr {\n        result += s.split(separator: Character(array[arr.firstIndex(of: s)!])).map { String($0) }.filter { $0 != \"\" }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [String], arr: [] as [String]) == [] as [String])"
    },
    {
        "id": 236,
        "code": "\n/// \nfunc f(array: [String]) -> String {\n    if array.count == 1 {\n        return array[0]\n    }\n    var result = array\n    var i = 0\n    while i < array.count - 1 {\n        for _ in 0..<2 {\n            result[i * 2] = array[i]\n            i += 1\n        }\n    }\n    return result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [\"ac8\", \"qk6\", \"9wg\"]) == \"ac8qk6qk6\")"
    },
    {
        "id": 237
    },
    {
        "id": 238,
        "code": "\nextension Int: Error {}\n        \n/// \nfunc f(ls: [[Int]], n: Int) -> Result<[Int], Int> {\n    var answer: [Int] = []\n    for i in ls {\n        if i[0] == n {\n            answer = i\n        }\n    }\n    return Result.success(answer)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ls: [[1, 9, 4], [83, 0, 5], [9, 6, 100]], n: 1) == .success([1, 9, 4]))"
    },
    {
        "id": 239,
        "code": "\nimport Foundation\n\nfunc f(text: String, froms: String) -> String {\n    let characterSet = CharacterSet(charactersIn: froms)\n    let trimmedText = text.trimmingCharacters(in: characterSet)\n    return String(trimmedText)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"0 t 1cos \", froms: \"st 0\\t\\n  \") == \"1co\")"
    },
    {
        "id": 240,
        "code": "import Foundation\n\nfunc f(float_number: Double) -> String {\n    let number = String(float_number)\n    if let dotIndex = number.firstIndex(of: \".\") {\n        let beforeDot = number[number.startIndex..<dotIndex]\n        let afterDot = number[number.index(after: dotIndex)...]\n        let paddedAfterDot = afterDot.padding(toLength: max(afterDot.count, 2), withPad: \"0\", startingAt: 0)\n        return beforeDot + \".\" + paddedAfterDot\n    }\n    return number + \".00\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(float_number: 3.121) == \"3.121\")"
    },
    {
        "id": 241,
        "code": "\n/// \nfunc f(postcode: String) -> String {\n    if let index = postcode.firstIndex(of: \"C\") {\n        return String(postcode[index...])\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(postcode: \"ED20 CW\") == \"CW\")"
    },
    {
        "id": 242,
        "code": "func f(book: String) -> String {\n    var a = book.split(separator: \":\")\n    if a[0].split(separator: \" \").last == a[1].split(separator: \" \").first {\n        return f(book: a[0].split(separator: \" \").dropLast().joined(separator: \" \") + \" \" + a[1])\n    }\n    return book\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(book: \"udhv zcvi nhtnfyd :erwuyawa pun\") == \"udhv zcvi nhtnfyd :erwuyawa pun\")"
    },
    {
        "id": 243,
        "code": "\n/// \nfunc f(text: String, char: String) -> Bool {\n    return char.lowercased() == char && text.lowercased() == text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abc\", char: \"e\") == true)"
    },
    {
        "id": 244
    },
    {
        "id": 245,
        "code": "func f(alphabet: String, s: String) -> [String] {\n    let sCharacters = Array(s)\n    let a = alphabet.filter { x in sCharacters.contains(x.uppercased().first ?? Character(\"\")) }\n    var result = a.map { String($0) }\n    \n    if s.uppercased() == s {\n        result.append(\"all_uppercased\")\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(alphabet: \"abcdefghijklmnopqrstuvwxyz\", s: \"uppercased # % ^ @ ! vz.\") == [] as [String])"
    },
    {
        "id": 246,
        "code": "\n/// \nfunc f(haystack: String, needle: String) -> Int {\n    for i in stride(from: haystack.count - needle.count, through: 0, by: -1) {\n        if haystack.suffix(from: haystack.index(haystack.startIndex, offsetBy: i)) == needle {\n            return i\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(haystack: \"345gerghjehg\", needle: \"345\") == -1)"
    },
    {
        "id": 247,
        "code": "import Foundation\n\nfunc f(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters.inverted) == nil {\n        return \"yes\"\n    } else if s.isEmpty {\n        return \"str is empty\"\n    } else {\n        return \"no\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"Boolean\") == \"yes\")"
    },
    {
        "id": 248
    },
    {
        "id": 249,
        "code": "\n/// \nfunc f(s: String) -> [String : Int] {\n    var count: [String: Int] = [:]\n    \n    for i in s {\n        if i.isLowercase {\n            count[String(i.lowercased())] = s.filter { $0.lowercased() == i.lowercased() }.count + (count[i.lowercased()] ?? 0)\n        } else {\n            count[String(i.lowercased())] = s.filter { $0.uppercased() == i.uppercased() }.count + (count[i.lowercased()] ?? 0)\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"FSA\") == [\"f\" : 1, \"s\" : 1, \"a\" : 1])"
    },
    {
        "id": 250
    },
    {
        "id": 251,
        "code": "\n\n/// \nfunc f(messages: [[String]]) -> String {\n    let phone_code = [\"+\", \"3\", \"5\", \"3\"]\n    var result = [String]()\n    for message in messages {\n        var newMessage = message\n        newMessage.append(contentsOf: phone_code)\n        result.append(newMessage.joined(separator: \";\"))\n    }\n    return result.joined(separator: \". \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(messages: [[\"Marie\", \"Nelson\", \"Oscar\"]]) == \"Marie;Nelson;Oscar;+;3;5;3\")"
    },
    {
        "id": 252
    },
    {
        "id": 253,
        "code": "\n/// \nfunc f(text: String, pref: String) -> String {\n    let length = pref.count\n    if pref == text.prefix(length) {\n        return String(text.suffix(text.count - length))\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"kumwwfv\", pref: \"k\") == \"umwwfv\")"
    },
    {
        "id": 254
    },
    {
        "id": 255,
        "code": "\n\n/// \nfunc f(text: String, fill: String, size: Int) -> String {\n    var size = size\n    if size < 0 {\n        size = -size\n    }\n    if text.count > size {\n        let startIndex = text.index(text.endIndex, offsetBy: -size)\n        return String(text[startIndex...])\n    }\n    let padding = String(repeating: fill, count: size - text.count)\n    return padding + text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"no asw\", fill: \"j\", size: 1) == \"w\")"
    },
    {
        "id": 256,
        "code": "import Foundation\n\nfunc f(text: String, sub: String) -> Int {\n    var a = 0\n    var b = text.count - 1\n\n    while a <= b {\n        let c = (a + b) // 2\n        if text.range(of: sub, options: .backwards, range: text.startIndex..<text.index(text.startIndex, offsetBy: c + 1)) != nil {\n            a = c + 1\n        } else {\n            b = c - 1\n        }\n    }\n\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"dorfunctions\", sub: \"2\") == 0)"
    },
    {
        "id": 257,
        "code": "func f(text: [String]) -> [[String]] {\n    var ls: [[String]] = []\n    for x in text {\n        ls.append(x.split(separator: \"\\n\").map { String($0) })\n    }\n    return ls\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: [\"Hello World\\n\\\"I am String\\\"\"]) == [[\"Hello World\", \"\\\"I am String\\\"\"]])"
    },
    {
        "id": 258
    },
    {
        "id": 259,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var new_text: [String] = []\n    for character in text {\n        if character.isUppercase {\n            new_text.insert(String(character), at: new_text.count / 2)\n        }\n    }\n    if new_text.isEmpty {\n        new_text = [\"-\"]\n    }\n    return new_text.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"String matching is a big part of RexEx library.\") == \"RES\")"
    },
    {
        "id": 260,
        "code": "\n/// \nfunc f(nums: [Int], start: Int, k: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.replaceSubrange(start..<start+k, with: nums[start..<start+k].reversed())\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 3, 4, 5, 6], start: 4, k: 2) == [1, 2, 3, 4, 6, 5])"
    },
    {
        "id": 261,
        "code": "\n/// \nfunc f(nums: [Int], target: Int) -> ([Int], [Int]) {\n    var lows: [Int] = []\n    var higgs: [Int] = []\n    \n    for i in nums {\n        if i < target {\n            lows.append(i)\n        } else {\n            higgs.append(i)\n        }\n    }\n    lows.removeAll()\n    \n    return (lows, higgs)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [12, 516, 5, 2, 3, 214, 51], target: 5) == ([] as [Int], [12, 516, 5, 214, 51]))"
    },
    {
        "id": 262,
        "code": "\n/// \nfunc f(nums: [Int]) -> String {\n    let score = [0: \"F\", 1: \"E\", 2: \"D\", 3: \"C\", 4: \"B\", 5: \"A\", 6: \"\"]\n    var result = [String]()\n    for num in nums {\n        result.append(score[num] ?? \"\")\n    }\n    return result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [4, 5]) == \"BA\")"
    },
    {
        "id": 263,
        "code": "func f(base: [String], delta: [[String]]) -> [String] {\n    var updatedBase = base\n    \n    for j in 0..<delta.count {\n        for i in 0..<updatedBase.count {\n            if updatedBase[i] == delta[j][0] {\n                assert(delta[j][1] != updatedBase[i])\n                updatedBase[i] = delta[j][1]\n            }\n        }\n    }\n    \n    return updatedBase\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(base: [\"gloss\", \"banana\", \"barn\", \"lawn\"], delta: [] as [[String]]) == [\"gloss\", \"banana\", \"barn\", \"lawn\"])"
    },
    {
        "id": 264,
        "code": "\nimport Foundation\n\nfunc f(test_str: String) -> String {\n    var s = test_str.replacingOccurrences(of: \"a\", with: \"A\")\n    s = s.replacingOccurrences(of: \"e\", with: \"A\")\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(test_str: \"papera\") == \"pApArA\")"
    },
    {
        "id": 265,
        "code": "\n/// \nfunc f(d: [Int : Int], k: Int) -> [Int : Int] {\n    var new_d: [Int: Int] = [:]\n    for (key, val) in d {\n        if key < k {\n            new_d[key] = val\n        }\n    }\n    return new_d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [1 : 2, 2 : 4, 3 : 3], k: 3) == [1 : 2, 2 : 4])"
    },
    {
        "id": 266,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var updatedNums = nums\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        if updatedNums[i] % 2 == 1 {\n            updatedNums.insert(updatedNums[i], at: i + 1)\n        }\n    }\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 3, 4, 6, -2]) == [2, 3, 3, 4, 6, -2])"
    },
    {
        "id": 267,
        "code": "\n\n/// \nfunc f(text: String, space: Int) -> String {\n    if space < 0 {\n        return text\n    }\n    let length = text.count\n    let padLength = length / 2 + space\n    let pad = String(repeating: \" \", count: max(0, padLength - length))\n    return text + pad\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"sowpf\", space: -7) == \"sowpf\")"
    },
    {
        "id": 268,
        "code": "func f(s: String, separator: String) -> String {\n    var new_s = Array(s)\n    for i in 0..<s.count {\n        if String(new_s[i]) == separator {\n            new_s[i] = \"/\"\n            return new_s.map { String($0) }.joined(separator: \" \")\n        }\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"h grateful k\", separator: \" \") == \"h / g r a t e f u l   k\")"
    },
    {
        "id": 269,
        "code": "\nextension String: Error {}\n\nfunc f(array: [Int]) -> [Result<Int, String>] {\n    var newArray = array.map { Result<Int, String>.success($0) }\n    let zeroLen = (newArray.count - 1) % 3\n    for i in 0..<zeroLen {\n        newArray[i] = .failure(\"0\")\n    }\n    for i in stride(from: zeroLen + 1, to: newArray.count, by: 3) {\n        newArray[i - 1] = .failure(\"0\")\n        newArray[i] = .failure(\"0\")\n        if i + 1 < newArray.count {\n            newArray[i + 1] = .failure(\"0\")\n        }\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [9, 2]) == [.failure(\"0\"), .success(2)])"
    },
    {
        "id": 270,
        "code": "\n\nfunc f(dic: [Int : Int]) -> [Int : Int] {\n    var d: [Int : Int] = [:]\n    for key in dic.keys {\n        d[key] = dic[key] ?? 0\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dic: [:] as [Int : Int]) == [:] as [Int : Int])"
    },
    {
        "id": 271,
        "code": "import Foundation\n\nfunc f(text: String, c: String) -> String {\n    var ls = Array(text)\n    guard let lastIndex = text.lastIndex(of: Character(c)) else {\n        fatalError(\"Text has no \\(c)\")\n    }\n    ls.remove(at: text.distance(from: text.startIndex, to: lastIndex))\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"uufhl\", c: \"l\") == \"uufh\")"
    },
    {
        "id": 272
    },
    {
        "id": 273,
        "code": "\n/// \nfunc f(name: String) -> String {\n    var new_name = \"\"\n    var reversedName = String(name.reversed())\n    \n    for n in reversedName {\n        if n != \".\" && new_name.filter({ $0 == \".\" }).count < 2 {\n            new_name = String(n) + new_name\n        } else {\n            break\n        }\n    }\n    \n    return new_name\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(name: \".NET\") == \"NET\")"
    },
    {
        "id": 274,
        "code": "\n/// \nfunc f(nums: [Int], target: Int) -> Int {\n    var count = 0\n    for n1 in nums {\n        for n2 in nums {\n            count += (n1 + n2 == target) ? 1 : 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 3], target: 4) == 3)"
    },
    {
        "id": 275,
        "code": "\n/// \nfunc f(dic: [Int : String]) -> [String : Int] {\n    var dic2 = [String: Int]()\n    for (key, value) in dic {\n        dic2[value] = key\n    }\n    return dic2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dic: [-1 : \"a\", 0 : \"b\", 1 : \"c\"]) == [\"a\" : -1, \"b\" : 0, \"c\" : 1])"
    },
    {
        "id": 276,
        "code": "\n/// \nfunc f(a: [Int]) -> [Int] {\n    var a = a\n    if a.count >= 2 && a[0] > 0 && a[1] > 0 {\n        a.reverse()\n        return a\n    }\n    a.append(0)\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: [] as [Int]) == [0])"
    },
    {
        "id": 277,
        "code": "\n/// \nfunc f(lst: [Int], mode: Int) -> [Int] {\n    var result = lst\n    if mode != 0 {\n        result.reverse()\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [1, 2, 3, 4], mode: 1) == [4, 3, 2, 1])"
    },
    {
        "id": 278,
        "code": "\n/// \nfunc f(array1: [Int], array2: [Int]) -> [Int : [Int]] {\n    var result = [Int: [Int]]()\n    for key in array1 {\n        result[key] = array2.filter { $0 < key * 2 }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array1: [0, 132], array2: [5, 991, 32, 997]) == [0 : [] as [Int], 132 : [5, 32]])"
    },
    {
        "id": 279,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var ans = \"\"\n    var text = text\n    while text != \"\" {\n        let parts = text.split(separator: \"(\", maxSplits: 1, omittingEmptySubsequences: false)\n        let x = String(parts[0])\n        let remainder = parts.count > 1 ? String(parts[1]) : \"\"\n        ans = x + \"(\" + ans\n        if remainder != \"\" {\n            ans += \"|\"\n            text = remainder\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\") == \"\")"
    },
    {
        "id": 280,
        "code": "\nimport XCTest\n\nvar g: String = \"\"\nvar field: String = \"\"\n\nfunc f(text: String) -> String {\n    field = text.replacingOccurrences(of: \" \", with: \"\")\n    g = text.replacingOccurrences(of: \"0\", with: \" \")\n    return text.replacingOccurrences(of: \"1\", with: \"i\")\n}\n\nfunc testF() {\n    XCTAssertEqual(f(text: \"example\"), \"example\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"00000000 00000000 01101100 01100101 01101110\") == \"00000000 00000000 0ii0ii00 0ii00i0i 0ii0iii0\")"
    },
    {
        "id": 281,
        "code": "\n/// \nfunc f(c: [AnyHashable : AnyHashable], index: AnyHashable, value: AnyHashable) -> [AnyHashable : AnyHashable] {\n    var c = c\n    c[index] = value\n    if let numericValue = value as? Int, numericValue >= 3 {\n        c.updateValue(\"xcrWt\", forKey: \"message\")\n    } else {\n        c.removeValue(forKey: \"message\")\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(c: [1 : 2, 3 : 4, 5 : 6, \"message\" : \"qrTHo\"], index: 8, value: 2) == [1 : 2, 3 : 4, 5 : 6, 8 : 2])"
    },
    {
        "id": 282
    },
    {
        "id": 283,
        "code": "\n/// \nfunc f(dictionary: [String : Int], key: String) -> String {\n    var updatedDictionary = dictionary\n    updatedDictionary.removeValue(forKey: key)\n    if let minKey = updatedDictionary.keys.min(), minKey == key {\n        return updatedDictionary.keys.first ?? \"\"\n    }\n    return key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dictionary: [\"Iron Man\" : 4, \"Captain America\" : 3, \"Black Panther\" : 0, \"Thor\" : 1, \"Ant-Man\" : 6], key: \"Iron Man\") == \"Iron Man\")"
    },
    {
        "id": 284,
        "code": "\n/// \nfunc f(text: String, prefix: String) -> String {\n    var idx = 0\n    for letter in prefix {\n        if text[text.index(text.startIndex, offsetBy: idx)] != letter {\n            return \"\"\n        }\n        idx += 1\n    }\n    return String(text.suffix(text.count - idx))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"bestest\", prefix: \"bestest\") == \"\")"
    },
    {
        "id": 285,
        "code": "\n/// \nfunc f(text: String, ch: String) -> Int {\n    return text.filter { $0 == Character(ch) }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"This be Pirate's Speak for 'help'!\", ch: \" \") == 5)"
    },
    {
        "id": 286
    },
    {
        "id": 287,
        "code": "\n/// \nfunc f(name: String) -> String {\n    var result = name\n    if name == name.lowercased() {\n        result = name.uppercased()\n    } else {\n        result = name.lowercased()\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(name: \"Pinneaple\") == \"pinneaple\")"
    },
    {
        "id": 288,
        "code": "\n/// \nfunc f(d: [Int : Int]) -> [(Int, Int)] {\n    let sortedPairs = d.sorted { String($0.key) + String($0.value) < String($1.key) + String($1.value) }\n    return sortedPairs.filter { $0.key < $0.value }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [55 : 4, 4 : 555, 1 : 3, 99 : 21, 499 : 4, 71 : 7, 12 : 6]) == [(1, 3), (4, 555)])"
    },
    {
        "id": 289,
        "code": "\n\n/// \nfunc f(code: String) -> String {\n    let encoded = code.utf8\n    let encodedString = \"b'\\(encoded)'\"\n    return \"\\(code): \\(encodedString)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(code: \"148\") == \"148: b'148'\")"
    },
    {
        "id": 290,
        "code": "import Foundation\n\nfunc f(text: String, prefix: String) -> String {\n    if text.hasPrefix(prefix) {\n        return String(text.dropFirst(prefix.count))\n    }\n    if text.contains(prefix) {\n        return text.replacingOccurrences(of: prefix, with: \"\").trimmingCharacters(in: .whitespaces)\n    }\n    return text.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abixaaaily\", prefix: \"al\") == \"ABIXAAAILY\")"
    },
    {
        "id": 291
    },
    {
        "id": 292,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let new_text = text.map { c in\n        return c.isNumber ? String(c) : \"*\"\n    }\n    return new_text.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"5f83u23saa\") == \"5*83*23***\")"
    },
    {
        "id": 293,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var s = text.lowercased()\n    for i in 0..<s.count {\n        if s[s.index(s.startIndex, offsetBy: i)] == \"x\" {\n            return \"no\"\n        }\n    }\n    return text.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"dEXE\") == \"no\")"
    },
    {
        "id": 294
    },
    {
        "id": 295,
        "code": "\n/// \nfunc f(fruits: [String]) -> [String] {\n    var modifiedFruits = fruits\n    if modifiedFruits.last == modifiedFruits.first {\n        return [\"no\"]\n    } else {\n        modifiedFruits.removeFirst()\n        modifiedFruits.removeLast()\n        modifiedFruits.removeFirst()\n        modifiedFruits.removeLast()\n        return modifiedFruits\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(fruits: [\"apple\", \"apple\", \"pear\", \"banana\", \"pear\", \"orange\", \"orange\"]) == [\"pear\", \"banana\", \"pear\"])"
    },
    {
        "id": 296,
        "code": "import Foundation\n\nfunc f(url: String) -> String {\n    if url.hasPrefix(\"http://www.\") {\n        return String(url.dropFirst(\"http://www.\".count))\n    } else {\n        return url\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(url: \"https://www.www.ekapusta.com/image/url\") == \"https://www.www.ekapusta.com/image/url\")"
    },
    {
        "id": 297,
        "code": "\n/// \nfunc f(num: Int) -> String {\n    if 0 < num && num < 1000 && num != 6174 {\n        return \"Half Life\"\n    }\n    return \"Not found\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: 6173) == \"Not found\")"
    },
    {
        "id": 298,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var new_text = Array(text)\n    for i in 0..<new_text.count {\n        let character = new_text[i]\n        let new_character = String(character).uppercased() == String(character) ? String(character).lowercased() : String(character).uppercased()\n        new_text[i] = Character(new_character)\n    }\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"dst vavf n dmv dfvm gamcu dgcvb.\") == \"DST VAVF N DMV DFVM GAMCU DGCVB.\")"
    },
    {
        "id": 299,
        "code": "\n/// \nfunc f(text: String, char: String) -> String {\n    if !text.hasSuffix(char) {\n        return f(text: char + text, char: char)\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"staovk\", char: \"k\") == \"staovk\")"
    },
    {
        "id": 300,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var count = 1\n    var nums = nums\n    for i in stride(from: count, to: nums.count - 1, by: 2) {\n        nums[i] = max(nums[i], nums[count-1])\n        count += 1\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 3]) == [1, 2, 3])"
    },
    {
        "id": 301
    },
    {
        "id": 302,
        "code": "\nimport Foundation\n\nfunc f(string: String) -> String {\n    return string.replacingOccurrences(of: \"needles\", with: \"haystacks\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"wdeejjjzsjsjjsxjjneddaddddddefsfd\") == \"wdeejjjzsjsjjsxjjneddaddddddefsfd\")"
    },
    {
        "id": 303,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var i = (text.count + 1) / 2\n    var result = Array(text)\n    while i < text.count {\n        let t = result[i].lowercased()\n        if t == String(result[i]) {\n            i += 1\n        } else {\n            result[i] = Character(t)\n        }\n        i += 2\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mJkLbn\") == \"mJklbn\")"
    },
    {
        "id": 304,
        "code": "func f(d: [Int : Int]) -> [Int : Int] {\n    var mutableDict = d\n    let key1 = mutableDict.sorted { $0.key > $1.key }.first!.key\n    let val1 = mutableDict.removeValue(forKey: key1)!\n    let key2 = mutableDict.sorted { $0.key > $1.key }.first!.key\n    let val2 = mutableDict.removeValue(forKey: key2)!\n    return [key1: val1, key2: val2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [2 : 3, 17 : 3, 16 : 6, 18 : 6, 87 : 7]) == [87 : 7, 18 : 6])"
    },
    {
        "id": 305,
        "code": "\n/// \nfunc f(text: String, char: String) -> String {\n    var length = text.count\n    var index = -1\n    for (i, character) in text.enumerated() {\n        if String(character) == char {\n            index = i\n        }\n    }\n    if index == -1 {\n        index = length / 2\n    }\n    var new_text = Array(text)\n    new_text.remove(at: index)\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"o horseto\", char: \"r\") == \"o hoseto\")"
    },
    {
        "id": 306,
        "code": "\n\nextension Int: Error {}\n\nfunc f(nums: [Result<String, Int>]) -> [Int] {\n    var digits: [Int] = []\n    for num in nums {\n        switch num {\n        case .success(let stringNum):\n            guard let intNum = Int(stringNum) else { continue }\n            digits.append(intNum)\n        case .failure(let intNum):\n            digits.append(intNum)\n        }\n    }\n    return digits\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [.failure(0), .failure(6), .success(\"1\"), .success(\"2\"), .failure(0)]) == [0, 6, 1, 2, 0])"
    },
    {
        "id": 307,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var rtext = Array(text)\n    for i in 1..<(rtext.count - 1) {\n        rtext.insert(\"|\", at: i + 1)\n    }\n    return String(rtext)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"pxcznyf\") == \"px|||||cznyf\")"
    },
    {
        "id": 308,
        "code": "\n/// \nfunc f(strings: [String]) -> [String : Int] {\n    var occurrences: [String: Int] = [:]\n    \n    for string in strings {\n        if occurrences[string] == nil {\n            occurrences[string] = strings.filter { $0 == string }.count\n        }\n    }\n    \n    return occurrences\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strings: [\"La\", \"Q\", \"9\", \"La\", \"La\"]) == [\"La\" : 3, \"Q\" : 1, \"9\" : 1])"
    },
    {
        "id": 309,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    var updatedText = text + suffix\n    while updatedText.hasSuffix(suffix) {\n        updatedText = String(updatedText.dropLast())\n    }\n    return updatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"faqo osax f\", suffix: \"f\") == \"faqo osax \")"
    },
    {
        "id": 310,
        "code": "\n/// \nfunc f(strands: [String]) -> String {\n    var subs = strands\n    for i in 0..<subs.count {\n        let j = subs[i]\n        for _ in 0..<(j.count / 2) {\n            subs[i] = String(j.last!) + j.dropFirst().dropLast() + String(j.first!)\n        }\n    }\n    return subs.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strands: [\"__\", \"1\", \".\", \"0\", \"r0\", \"__\", \"a_j\", \"6\", \"__\", \"6\"]) == \"__1.00r__j_a6__6\")"
    },
    {
        "id": 311,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    let newText = text.replacingOccurrences(of: \"#\", with: \"1\").replacingOccurrences(of: \"$\", with: \"5\")\n    let numeric = CharacterSet.decimalDigits\n    return newText.rangeOfCharacter(from: numeric.inverted) == nil ? \"yes\" : \"no\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"A\") == \"no\")"
    },
    {
        "id": 312,
        "code": "import Foundation\n\nfunc f(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) == nil {\n        return \"True\"\n    }\n    return \"False\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"777\") == \"True\")"
    },
    {
        "id": 313,
        "code": "\n\n/// \nfunc f(s: String, l: Int) -> String {\n    let diff = l - s.count\n    var newS = s\n    if diff > 0 {\n        newS += String(repeating: \"=\", count: diff)\n    }\n    if let index = newS.lastIndex(of: \"=\") {\n        return String(newS[..<index])\n    }\n    return newS\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"urecord\", l: 8) == \"urecord\")"
    },
    {
        "id": 314
    },
    {
        "id": 315,
        "code": "\n\nimport Foundation\n\nfunc f(challenge: String) -> String {\n    return challenge.lowercased().replacingOccurrences(of: \"l\", with: \",\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(challenge: \"czywZ\") == \"czywz\")"
    },
    {
        "id": 316,
        "code": "func f(name: String) -> String {\n    return \"| \" + name.split(separator: \" \").joined(separator: \" \") + \" |\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(name: \"i am your father\") == \"| i am your father |\")"
    },
    {
        "id": 317,
        "code": "\nimport Foundation\n\nfunc f(text: String, a: String, b: String) -> String {\n    let text = text.replacingOccurrences(of: a, with: b)\n    return text.replacingOccurrences(of: b, with: a)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \" vup a zwwo oihee amuwuuw! \", a: \"a\", b: \"u\") == \" vap a zwwo oihee amawaaw! \")"
    },
    {
        "id": 318,
        "code": "\n/// \nfunc f(value: String, char: String) -> Int {\n    var total = 0\n    for c in value {\n        if c == Character(char) || c == Character(char.lowercased()) {\n            total += 1\n        }\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(value: \"234rtccde\", char: \"e\") == 1)"
    },
    {
        "id": 319
    },
    {
        "id": 320
    },
    {
        "id": 321,
        "code": "\n/// \nfunc f(update: [String : Int], starting: [String : Int]) -> [String : Int] {\n    var d = starting\n    for (key, value) in update {\n        if let existingValue = d[key] {\n            d[key] = existingValue + value\n        } else {\n            d[key] = value\n        }\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(update: [:] as [String : Int], starting: [\"desciduous\" : 2]) == [\"desciduous\" : 2])"
    },
    {
        "id": 322,
        "code": "\n/// \nfunc f(chemicals: [String], num: Int) -> [String] {\n    var fish = Array(chemicals[1...])\n    var chemicalsCopy = chemicals\n    chemicalsCopy.reverse()\n    \n    for _ in 0..<num {\n        fish.append(chemicalsCopy.remove(at: 1))\n    }\n    \n    chemicalsCopy.reverse()\n    return chemicalsCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(chemicals: [\"lsi\", \"s\", \"t\", \"t\", \"d\"], num: 0) == [\"lsi\", \"s\", \"t\", \"t\", \"d\"])"
    },
    {
        "id": 323,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    return text.split(separator: \"\\n\").count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ncdsdfdaaa0a1cdscsk*XFd\") == 1)"
    },
    {
        "id": 324,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var asc = nums\n    var desc: [Int] = []\n    var copy = asc\n    copy.reverse()\n    desc = Array(copy.prefix(copy.count/2))\n    return desc + asc + desc\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 325,
        "code": "func f(s: String) -> Bool {\n    var l = Array(s)\n    for i in 0..<l.count {\n        l[i] = Character(l[i].lowercased())\n        if !l[i].isNumber {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"\") == true)"
    },
    {
        "id": 326,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var number = 0\n    for t in text {\n        if t.isNumber {\n            number += 1\n        }\n    }\n    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Thisisastring\") == 0)"
    },
    {
        "id": 327,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var new = [Int]()\n    var i = lst.count - 1\n    for _ in 0..<lst.count {\n        if i % 2 == 0 {\n            new.append(-lst[i])\n        } else {\n            new.append(lst[i])\n        }\n        i -= 1\n    }\n    return new\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [1, 7, -1, -3]) == [-3, 1, 7, -1])"
    },
    {
        "id": 328,
        "code": "\n\n/// \nfunc f(array: [Int], L: Int) -> [Int] {\n    if L <= 0 {\n        return array\n    } else if array.count < L {\n        var newArray = [Int]()\n        for _ in 0..<(L - array.count) {\n            newArray += array\n        }\n        return array + newArray\n    }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 3], L: 4) == [1, 2, 3, 1, 2, 3])"
    },
    {
        "id": 329
    },
    {
        "id": 330,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var ans = \"\"\n    for char in text {\n        if char.isNumber {\n            ans.append(char)\n        } else {\n            ans.append(\" \")\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"m4n2o\") == \" 4 2 \")"
    },
    {
        "id": 331,
        "code": "\n\nimport Foundation\n\nfunc f(strand: String, zmnc: String) -> Int {    \n    var strand = strand\n    var poz = strand.range(of: zmnc)\n    while poz != nil {\n        strand.removeSubrange(poz!)\n        poz = strand.range(of: zmnc)\n    }\n    let lastIndex = strand.range(of: zmnc, options: [], range: nil, locale: nil)?.lowerBound.utf16Offset(in: strand)\n    return lastIndex ?? -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strand: \"\", zmnc: \"abc\") == -1)"
    },
    {
        "id": 332,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    let count = nums.count\n    if count == 0 {\n        nums = Array(repeating: 0, count: nums.removeLast())\n    } else if count % 2 == 0 {\n        nums.removeAll()\n    } else {\n        nums.removeFirst(count / 2)\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-6, -2, 1, -3, 0, 1]) == [] as [Int])"
    },
    {
        "id": 333,
        "code": "\n/// \nfunc f(places: [Int], lazy: [Int]) -> Int {\n    var sortedPlaces = places.sorted()\n    for l in lazy {\n        if let index = sortedPlaces.firstIndex(of: l) {\n            sortedPlaces.remove(at: index)\n        }\n    }\n    \n    if sortedPlaces.count == 1 {\n        return 1\n    }\n    \n    for i in 0..<sortedPlaces.count {\n        if !sortedPlaces.contains(sortedPlaces[i] + 1) {\n            return i + 1\n        }\n    }\n    \n    return sortedPlaces.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(places: [375, 564, 857, 90, 728, 92], lazy: [728]) == 1)"
    },
    {
        "id": 334,
        "code": "\n/// \nfunc f(a: String, b: [String]) -> String {\n    return b.joined(separator: a)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"00\", b: [\"nU\", \" 9 rCSAz\", \"w\", \" lpA5BO\", \"sizL\", \"i7rlVr\"]) == \"nU00 9 rCSAz00w00 lpA5BO00sizL00i7rlVr\")"
    },
    {
        "id": 335,
        "code": "\n/// \nfunc f(text: String, to_remove: String) -> String {\n    var new_text = Array(text)\n    if new_text.contains(Character(to_remove)) {\n        if let index = new_text.firstIndex(of: Character(to_remove)) {\n            new_text.remove(at: index)\n            new_text.insert(\"?\", at: index)\n            if let questionMarkIndex = new_text.firstIndex(of: \"?\") {\n                new_text.remove(at: questionMarkIndex)\n            }\n        }\n    }\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"sjbrlfqmw\", to_remove: \"l\") == \"sjbrfqmw\")"
    },
    {
        "id": 336,
        "code": "import Foundation\n\nfunc f(s: String, sep: String) -> String {\n    let s = s + sep\n    if let range = s.range(of: sep, options: .backwards) {\n        return String(s[..<range.lowerBound])\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"234dsfssdfs333324314\", sep: \"s\") == \"234dsfssdfs333324314\")"
    },
    {
        "id": 337,
        "code": "\n/// \nfunc f(txt: String) -> String {\n    var d = [String]()\n    \n    for c in txt {\n        if c.isNumber {\n            continue\n        }\n        if c.isLowercase {\n            d.append(String(c).uppercased())\n        } else if c.isUppercase {\n            d.append(String(c).lowercased())\n        }\n    }\n    \n    return d.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: \"5ll6\") == \"LL\")"
    },
    {
        "id": 338,
        "code": "\n\nfunc f(my_dict: [String : Int]) -> [Int : String] {\n    var result: [Int : String] = [:]\n    for (key, value) in my_dict {\n        result[value] = key\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(my_dict: [\"a\" : 1, \"b\" : 2, \"c\" : 3, \"d\" : 2]) == [1 : \"a\", 2 : \"d\", 3 : \"c\"])"
    },
    {
        "id": 339,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> Int {\n    var d = 0\n    let elemStr = String(elem)\n    \n    for i in array {\n        if String(i) == elemStr {\n            d += 1\n        }\n    }\n    \n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [-1, 2, 1, -8, -8, 2], elem: 2) == 2)"
    },
    {
        "id": 340,
        "code": "\n/// \nfunc f(text: String) -> String {\n    if let uppercaseIndex = text.firstIndex(of: \"A\") {\n        return String(text[..<uppercaseIndex]) + text[text.index(after: text.firstIndex(of: \"a\")!)...]\n    } else {\n        return String(text.sorted())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"E jIkx HtDpV G\") == \"   DEGHIVjkptx\")"
    },
    {
        "id": 341,
        "code": "\n\n/// \nfunc f(cart: [Int : Int]) -> [Int : Int] {\n    var mutableCart = cart\n    while mutableCart.count > 5 {\n        mutableCart.removeValue(forKey: mutableCart.keys.first!)\n    }\n    return mutableCart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(cart: [:] as [Int : Int]) == [:] as [Int : Int])"
    },
    {
        "id": 342,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return text.filter({ $0 == \"-\" }).count == text.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"---123-4\") == false)"
    },
    {
        "id": 343
    },
    {
        "id": 344,
        "code": "\n\nimport Foundation\n\nfunc f(lst: [Int]) -> [Int] {\n    var newList = lst\n    newList.sort()\n    newList.reverse()\n    return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [6, 4, 2, 8, 15]) == [6, 4, 2, 8, 15])"
    },
    {
        "id": 345,
        "code": "\nfunc f(a: String, b: String) -> (String, String) {\n    if a < b {\n        return (b, a)\n    }\n    return (a, b)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"ml\", b: \"mv\") == (\"mv\", \"ml\"))"
    },
    {
        "id": 346,
        "code": "func f(filename: String) -> Bool {\n    let suffix = filename.split(separator: \".\").last.map(String.init) ?? \"\"\n    let reversedSuffix = String(suffix.reversed())\n    let f2 = filename + reversedSuffix\n    return f2.hasSuffix(suffix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(filename: \"docs.doc\") == false)"
    },
    {
        "id": 347
    },
    {
        "id": 348,
        "code": "\n\n/// \nfunc f(dictionary: [Int : Int?]) -> [Int : Int?] {\n    return dictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dictionary: [563 : 555, 133 : nil]) == [563 : 555, 133 : nil])"
    },
    {
        "id": 349,
        "code": "\n\nfunc f(dictionary: [String : Int]) -> [String : Int] {\n    var dictionary = dictionary\n    dictionary[\"1049\"] = 55\n    if let (key, value) = dictionary.popFirst() {\n        dictionary[key] = value\n    }\n    return dictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dictionary: [\"noeohqhk\" : 623]) == [\"noeohqhk\" : 623, \"1049\" : 55])"
    },
    {
        "id": 350
    },
    {
        "id": 351,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    var mutableText = text\n    while mutableText.contains(\"nnet lloP\") {\n        mutableText = mutableText.replacingOccurrences(of: \"nnet lloP\", with: \"nnet loLp\")\n    }\n    return mutableText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a_A_b_B3 \") == \"a_A_b_B3 \")"
    },
    {
        "id": 352,
        "code": "\n/// \nfunc f(nums: [Int]) -> Int {\n    return nums[nums.count/2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-1, -3, -5, -7, 0]) == -5)"
    },
    {
        "id": 353,
        "code": "\n/// \nfunc f(x: [Int]) -> Int {\n    if x.isEmpty {\n        return -1\n    } else {\n        var cache = [Int: Int]()\n        for item in x {\n            if let count = cache[item] {\n                cache[item] = count + 1\n            } else {\n                cache[item] = 1\n            }\n        }\n        return cache.values.max() ?? 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: [1, 0, 2, 2, 0, 0, 0, 1]) == 4)"
    },
    {
        "id": 354
    },
    {
        "id": 355,
        "code": "\n/// \nfunc f(text: String, prefix: String) -> String {\n    return String(text.suffix(text.count - prefix.count))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"123x John z\", prefix: \"z\") == \"23x John z\")"
    },
    {
        "id": 356,
        "code": "\n/// \nfunc f(array: [Int], num: Int) -> [Int] {\n    var reverse = false\n    var num = num\n    if num < 0 {\n        reverse = true\n        num *= -1\n    }\n    var array = Array(array.reversed())\n    array = Array(repeating: array, count: num).flatMap { $0 }\n    \n    if reverse {\n        array = Array(array.reversed())\n    }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2], num: 1) == [2, 1])"
    },
    {
        "id": 357,
        "code": "\n/// \nfunc f(s: String) -> String {\n    var r: [Character] = []\n    for i in stride(from: s.count - 1, through: 0, by: -1) {\n        r.append(s[s.index(s.startIndex, offsetBy: i)])\n    }\n    return String(r)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"crew\") == \"werc\")"
    },
    {
        "id": 358,
        "code": "func f(text: String, value: String) -> String {\n    var indexes = [Int]()\n    for i in 0..<text.count {\n        let currentIndex = text.index(text.startIndex, offsetBy: i)\n        if text[currentIndex] == Character(value) && (i == 0 || text[text.index(currentIndex, offsetBy: -1)] != Character(value)) {\n            indexes.append(i)\n        }\n    }\n\n    if indexes.count % 2 == 1 {\n        return text\n    }\n\n    let startIndex = text.index(text.startIndex, offsetBy: indexes[0] + 1)\n    let endIndex = text.index(text.startIndex, offsetBy: indexes[indexes.count - 1])\n    return String(text[startIndex..<endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"btrburger\", value: \"b\") == \"tr\")"
    },
    {
        "id": 359,
        "code": "\n\n/// \nfunc f(lines: [String]) -> [String] {\n    var newLines = lines\n    for i in 0..<newLines.count {\n        let padding = String(repeating: \" \", count: lines.last!.count - lines[i].count)\n        newLines[i] = padding + lines[i] + padding\n    }\n    return newLines\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lines: [\"dZwbSR\", \"wijHeq\", \"qluVok\", \"dxjxbF\"]) == [\"dZwbSR\", \"wijHeq\", \"qluVok\", \"dxjxbF\"])"
    },
    {
        "id": 360,
        "code": "\n/// \nfunc f(text: String, n: Int) -> String {\n    if text.count <= 2 {\n        return text\n    }\n    let leadingChars = String(repeating: text.first!, count: n - text.count + 1)\n    return leadingChars + String(text.suffix(text.count - 1).dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"g\", n: 15) == \"g\")"
    },
    {
        "id": 361,
        "code": "func f(text: String) -> Int {\n    return text.split(separator: \":\")[0].filter({$0 == \"#\"}).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"#! : #!\") == 1)"
    },
    {
        "id": 362,
        "code": "\n/// \nfunc f(text: String) -> String {\n    for i in 0..<(text.count - 1) {\n        let startIndex = text.index(text.startIndex, offsetBy: i)\n        if text[startIndex...].lowercased() == text[startIndex...] {\n            let nextIndex = text.index(startIndex, offsetBy: 1)\n            return String(text[nextIndex...])\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wrazugizoernmgzu\") == \"razugizoernmgzu\")"
    },
    {
        "id": 363,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var sortedNums = nums.sorted()\n    var newNums = [sortedNums[sortedNums.count/2]]\n    \n    if sortedNums.count % 2 == 0 {\n        newNums = [sortedNums[sortedNums.count/2 - 1], sortedNums[sortedNums.count/2]]\n    }\n    \n    for i in 0..<(sortedNums.count/2) {\n        newNums.insert(sortedNums[sortedNums.count-i-1], at: 0)\n        newNums.append(sortedNums[i])\n    }\n    \n    return newNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1]) == [1])"
    },
    {
        "id": 364
    },
    {
        "id": 365,
        "code": "func f(n: String, s: String) -> String {\n    if s.hasPrefix(n) {\n        let splitted = s.split(separator: Character(n), maxSplits: 1)\n        if let pre = splitted.first {\n            return String(pre) + n + String(s.dropFirst(n.count))\n        }\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: \"xqc\", s: \"mRcwVqXsRDRb\") == \"mRcwVqXsRDRb\")"
    },
    {
        "id": 366
    },
    {
        "id": 367,
        "code": "\n/// \nfunc f(nums: [Int], rmvalue: Int) -> [Int] {\n    var res = nums\n    while res.contains(rmvalue) {\n        if let index = res.firstIndex(of: rmvalue) {\n            let popped = res.remove(at: index)\n            if popped != rmvalue {\n                res.append(popped)\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [6, 2, 1, 1, 4, 1], rmvalue: 5) == [6, 2, 1, 1, 4, 1])"
    },
    {
        "id": 368
    },
    {
        "id": 369
    },
    {
        "id": 370,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    for char in text {\n        if !char.isWhitespace {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"     i\") == false)"
    },
    {
        "id": 371,
        "code": "\n/// \nfunc f(nums: [Int]) -> Int {\n    var numsCopy = nums\n    numsCopy.removeAll(where: { $0 % 2 != 0 })\n    \n    var sum = 0\n    for num in numsCopy {\n        sum += num\n    }\n    \n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [11, 21, 0, 11]) == 0)"
    },
    {
        "id": 372,
        "code": "\n/// \nfunc f(list_: [String], num: Int) -> [String] {\n    var temp: [String] = []\n    for i in list_ {\n        let newString = String(repeating: \"\\(i),\", count: num / 2)\n        temp.append(newString)\n    }\n    return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(list_: [\"v\"], num: 1) == [\"\"])"
    },
    {
        "id": 373,
        "code": "func f(orig: [Int]) -> [Int] {\n    var copy = orig\n    copy.append(100)\n    _ = copy.popLast()\n    return copy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(orig: [1, 2, 3]) == [1, 2, 3])"
    },
    {
        "id": 374,
        "code": "\n/// \nfunc f(seq: [String], v: String) -> [String] {\n    var result: [String] = []\n    for i in seq {\n        if i.hasSuffix(v) {\n            result.append(i + i)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(seq: [\"oH\", \"ee\", \"mb\", \"deft\", \"n\", \"zz\", \"f\", \"abA\"], v: \"zz\") == [\"zzzz\"])"
    },
    {
        "id": 375
    },
    {
        "id": 376,
        "code": "\n/// \nfunc f(text: String) -> String {\n    for i in 0..<text.count {\n        let index = text.index(text.startIndex, offsetBy: i)\n        if text[..<index].hasPrefix(\"two\") {\n            let substringIndex = text.index(text.startIndex, offsetBy: i)\n            return String(text[substringIndex...])\n        }\n    }\n    return \"no\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"2two programmers\") == \"no\")"
    },
    {
        "id": 377,
        "code": "\n/// \nfunc f(text: String) -> String {\n    return text.split(separator: \"\\n\").joined(separator: \", \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"BYE\\nNO\\nWAY\") == \"BYE, NO, WAY\")"
    },
    {
        "id": 378
    },
    {
        "id": 379,
        "code": "\n\nextension Array: Error {}\n\nfunc f(nums: [Int]) -> Result<Bool, [Int]> {\n    for i in stride(from: nums.count-1, through: 0, by: -3) {\n        if nums[i] == 0 {\n            return .success(false)\n        }\n    }\n    return .failure(nums)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [0, 0, 1, 2, 1]) == .success(false))"
    },
    {
        "id": 380,
        "code": "import Foundation\n\nfunc f(text: String, delimiter: String) -> String {\n    let parts = text.rpartition(separator: delimiter)\n    return parts.0 + parts.2\n}\n\nextension String {\n    func rpartition(separator: String) -> (String, String, String) {\n        if let range = self.range(of: separator, options: .backwards) {\n            let before = String(self[..<range.lowerBound])\n            let match = String(self[range])\n            let after = String(self[range.upperBound...])\n            return (before, match, after)\n        } else {\n            return (self, \"\", \"\")\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"xxjarczx\", delimiter: \"x\") == \"xxjarcz\")"
    },
    {
        "id": 381,
        "code": "\n/// \nfunc f(text: String, num_digits: Int) -> String {\n    let width = max(1, num_digits)\n    return String(repeating: \"0\", count: max(0, width - text.count)) + text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"19\", num_digits: 5) == \"00019\")"
    },
    {
        "id": 382
    },
    {
        "id": 383,
        "code": "import Foundation\n\nfunc f(text: String, chars: String) -> String {\n    var result = Array(text)\n    while result.suffix(3).contains(where: { String($0) == chars }) {\n        result.removeAll { String($0) == String(chars) }\n        result.removeAll { String($0) == String(chars) }\n    }\n    return String(result).trimmingCharacters(in: CharacterSet(charactersIn: \".\"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ellod!p.nkyp.exa.bi.y.hain\", chars: \".n.in.ha.y\") == \"ellod!p.nkyp.exa.bi.y.hain\")"
    },
    {
        "id": 384,
        "code": "func f(text: String, chars: String) -> String {\n    var new_text = text\n    let charsArray = Array(chars)\n    var textArray = Array(text)\n    \n    while new_text.count > 0 && !textArray.isEmpty {\n        if charsArray.contains(new_text.first!) {\n            new_text.removeFirst()\n            textArray.removeFirst()\n        } else {\n            break\n        }\n    }\n    \n    return new_text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"asfdellos\", chars: \"Ta\") == \"sfdellos\")"
    },
    {
        "id": 385,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var i = 0\n    var new_list = [Int]()\n    while i < lst.count {\n        if lst[i] == lst[i+1..<lst.count].first(where: { $0 == lst[i] }) {\n            new_list.append(lst[i])\n            if new_list.count == 3 {\n                return new_list\n            }\n        }\n        i += 1\n    }\n    return new_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [0, 2, 1, 2, 6, 2, 6, 3, 0]) == [0, 2, 2])"
    },
    {
        "id": 386,
        "code": "func f(concat: String, di: [String : String]) -> String {\n    var updatedDict = di\n    let count = updatedDict.count\n    for i in 0..<count {\n        if let value = updatedDict[String(i)] {\n            for char in concat {\n                if value.contains(char) {\n                    updatedDict.removeValue(forKey: String(i))\n                    break\n                }\n            }\n        }\n    }\n    return \"Done!\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(concat: \"mid\", di: [\"0\" : \"q\", \"1\" : \"f\", \"2\" : \"w\", \"3\" : \"i\"]) == \"Done!\")"
    },
    {
        "id": 387,
        "code": "\n/// \nfunc f(nums: [Int], pos: Int, value: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.insert(value, at: pos)\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 1, 2], pos: 2, value: 0) == [3, 1, 0, 2])"
    },
    {
        "id": 388,
        "code": "\n/// \nfunc f(text: String, characters: String) -> String {\n    var characterList = Array(characters) + [\" \", \"_\"]\n    \n    var i = 0\n    while i < text.count && characterList.contains(text[text.index(text.startIndex, offsetBy: i)]) {\n        i += 1\n    }\n    \n    return String(text.suffix(from: text.index(text.startIndex, offsetBy: i)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"2nm_28in\", characters: \"nm\") == \"2nm_28in\")"
    },
    {
        "id": 389,
        "code": "\n\n/// \nfunc f(total: [String], arg: String) -> [String] {\n    var totalVar = total\n    for letter in arg {\n        totalVar.append(String(letter))\n    }\n    return totalVar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(total: [\"1\", \"2\", \"3\"], arg: \"nammo\") == [\"1\", \"2\", \"3\", \"n\", \"a\", \"m\", \"m\", \"o\"])"
    },
    {
        "id": 390,
        "code": "\n\nimport Foundation\n\nfunc f(text: String) -> Int? {\n    if text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {\n        return text.trimmingCharacters(in: .whitespacesAndNewlines).count\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \" \\t \") == 0)"
    },
    {
        "id": 391
    },
    {
        "id": 392,
        "code": "\n/// \nfunc f(text: String) -> String {\n    if text.uppercased() == text {\n        return \"ALL UPPERCASE\"\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Hello Is It MyClass\") == \"Hello Is It MyClass\")"
    },
    {
        "id": 393,
        "code": "func f(text: String) -> String {\n    let ls = String(text.reversed())\n    var text2 = \"\"\n    for i in stride(from: ls.count - 3, to: 0, by: -3) {\n        let substring = ls[ls.index(ls.startIndex, offsetBy: i)..<ls.index(ls.startIndex, offsetBy: i + 3)]\n        text2 += substring.map { String($0) }.joined(separator: \"---\") + \"---\"\n    }\n    return String(text2.dropLast(3))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"scala\") == \"a---c---s\")"
    },
    {
        "id": 394,
        "code": "func f(text: String) -> Int {\n    let k = text.split(separator: \"\\n\", maxSplits: Int.max, omittingEmptySubsequences: false)\n    var i = 0\n    for j in k {\n        if j.isEmpty {\n            return i\n        }\n        i += 1\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"2 m2 \\n\\nbike\") == 1)"
    },
    {
        "id": 395,
        "code": "\n/// \nfunc f(s: String) -> Int {\n    for i in 0..<s.count {\n        let char = s[s.index(s.startIndex, offsetBy: i)]\n        if char.isNumber {\n            return i + (char == \"0\" ? 1 : 0)\n        } else if char == \"0\" {\n            return -1\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"11\") == 0)"
    },
    {
        "id": 396,
        "code": "\n\nfunc f(ets: [Int : Int]) -> [Int : Int] {\n    var mutableEts = ets\n    for (key, value) in mutableEts {\n        mutableEts[key] = value * value\n    }\n    return mutableEts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ets: [:] as [Int : Int]) == [:] as [Int : Int])"
    },
    {
        "id": 397,
        "code": "\n\nextension Int: Error {}\n\nfunc f(ls: [Result<String, Int>]) -> [AnyHashable : Int] {\n    var dict = [AnyHashable : Int]()\n    for element in ls {\n        switch element {\n        case .success(let value):\n            dict[value] = 0\n        case .failure:\n            break\n        }\n    }\n    return dict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ls: [.success(\"x\"), .success(\"u\"), .success(\"w\"), .success(\"j\"), .success(\"3\"), .success(\"6\")]) == [\"x\" : 0, \"u\" : 0, \"w\" : 0, \"j\" : 0, \"3\" : 0, \"6\" : 0])"
    },
    {
        "id": 398
    },
    {
        "id": 399,
        "code": "import Foundation\n\nfunc f(text: String, old: String, new: String) -> String {\n    var text = text\n    \n    if old.count > 3 {\n        return text\n    }\n    \n    if text.contains(old) && !text.contains(\" \") {\n        return text.replacingOccurrences(of: old, with: String(repeating: new, count: old.count))\n    }\n    \n    while text.range(of: old) != nil {\n        text = text.replacingOccurrences(of: old, with: new)\n    }\n    \n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"avacado\", old: \"va\", new: \"-\") == \"a--cado\")"
    },
    {
        "id": 400,
        "code": "\n/// \nfunc f(multi_string: String) -> String {\n    let cond_string = multi_string.split(separator: \" \").map { $0.unicodeScalars.allSatisfy { $0.isASCII } }\n    if cond_string.contains(true) {\n        return multi_string.split(separator: \" \").filter { $0.unicodeScalars.allSatisfy { $0.isASCII } }.joined(separator: \", \")\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(multi_string: \"I am hungry! eat food.\") == \"I, am, hungry!, eat, food.\")"
    },
    {
        "id": 401,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    if !suffix.isEmpty && text.hasSuffix(suffix) {\n        return String(text.prefix(text.count - suffix.count))\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mathematics\", suffix: \"example\") == \"mathematics\")"
    },
    {
        "id": 402,
        "code": "\n/// \nfunc f(n: Int, l: [String]) -> [Int : Int] {\n    var archive = [Int: Int]()\n    for _ in 0..<n {\n        archive.removeAll()\n        for x in l {\n            archive[x.count + 10] = x.count * 10\n        }\n    }\n    return archive\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 0, l: [\"aaa\", \"bbb\"]) == [:] as [Int : Int])"
    },
    {
        "id": 403
    },
    {
        "id": 404,
        "code": "\n/// \nfunc f(no: [String]) -> Int {\n    var d = [String: Bool]()\n    no.forEach { d[$0] = false }\n    return d.keys.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(no: [\"l\", \"f\", \"h\", \"g\", \"s\", \"b\"]) == 6)"
    },
    {
        "id": 405,
        "code": "\n/// \nfunc f(xs: [Int]) -> [Int] {\n    var xs = xs\n    var new_x = xs.removeFirst() - 1\n    \n    while new_x <= xs[0] {\n        xs.removeFirst()\n        new_x -= 1\n    }\n    \n    xs.insert(new_x, at: 0)\n    \n    return xs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(xs: [6, 3, 4, 1, 2, 3, 5]) == [5, 3, 4, 1, 2, 3, 5])"
    },
    {
        "id": 406,
        "code": "func f(text: String) -> Bool {\n    var ls = Array(text)\n    ls[0] = Character(String(ls.last!).uppercased())\n    ls[ls.count-1] = Character(String(ls.first!).uppercased())\n    return String(ls) == text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Josh\") == false)"
    },
    {
        "id": 407,
        "code": "\n/// \nfunc f(s: [Int]) -> Int {\n    var s = s\n    while s.count > 1 {\n        s.removeAll()\n        s.append(s.count)\n    }\n    return s.removeLast()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: [6, 1, 2, 3]) == 0)"
    },
    {
        "id": 408,
        "code": "\n/// \nfunc f(m: [Int]) -> [Int] {\n    var reversedArray = m\n    reversedArray.reverse()\n    return reversedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(m: [-4, 6, 0, 4, -7, 2, -1]) == [-1, 2, -7, 4, 0, 6, -4])"
    },
    {
        "id": 409,
        "code": "func f(text: String, char: String) -> String {\n    var text = text\n    if !text.isEmpty {\n        if text.hasPrefix(char) {\n            text = String(text.dropFirst(char.count))\n        }\n        if let lastChar = text.last {\n            text = String(text.dropLast())\n            text.append(Character(String(lastChar).uppercased()))\n        }\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"querist\", char: \"u\") == \"querisT\")"
    },
    {
        "id": 410,
        "code": "\n\nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    for i in 0..<nums.count {\n        nums.insert(nums[i], at: i)\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 3, -1, 1, -2, 6]) == [1, 1, 1, 1, 1, 1, 1, 3, -1, 1, -2, 6])"
    },
    {
        "id": 411,
        "code": "\n/// \nfunc f(text: String, pref: String) -> Bool {\n    if let prefList = pref as? [String] {\n        return prefList.map({ text.hasPrefix($0) ? \"true\" : \"false\" }).joined(separator: \", \") == \"true\"\n    } else {\n        return text.hasPrefix(pref)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Hello World\", pref: \"W\") == false)"
    },
    {
        "id": 412,
        "code": "func f(start: Int, end: Int, interval: Int) -> Int {\n    var steps = Array(stride(from: start, through: end, by: interval))\n    if steps.contains(1) {\n        steps[steps.count - 1] = end + 1\n    }\n    return steps.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(start: 3, end: 10, interval: 1) == 8)"
    },
    {
        "id": 413,
        "code": "func f(s: String) -> String {\n    guard s.count >= 6 else {\n        return \"\"\n    }\n    \n    let startIndex = s.index(s.startIndex, offsetBy: 3)\n    let middleIndex = s.index(s.startIndex, offsetBy: 2)\n    let endIndex = s.index(s.startIndex, offsetBy: 5)\n    let endRange = s.index(s.startIndex, offsetBy: 6)\n    \n    let part1 = String(s[startIndex...])\n    let part2 = String(s[middleIndex])\n    let part3 = String(s[endIndex..<endRange])\n    \n    return part1 + part2 + part3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"jbucwc\") == \"cwcuc\")"
    },
    {
        "id": 414,
        "code": "\n/// \nfunc f(d: [String : [String]]) -> [String : [String]] {\n    var dCopy = d\n    for (key, var value) in dCopy {\n        for i in 0..<value.count {\n            value[i] = value[i].uppercased()\n        }\n        dCopy[key] = value\n    }\n    return dCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"X\" : [\"x\", \"y\"]]) == [\"X\" : [\"X\", \"Y\"]])"
    },
    {
        "id": 415,
        "code": "\n\nfunc f(array: [(Int, Int)]) -> [Int : Int]? {\n    var d = Dictionary(array, uniquingKeysWith: { (oldValue, newValue) in newValue })\n    for (key, value) in d {\n        if value < 0 || value > 9 {\n            return nil\n        }\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [(8, 5), (8, 2), (5, 3)]) == [8 : 2, 5 : 3])"
    },
    {
        "id": 416
    },
    {
        "id": 417,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var mutableList = lst\n    mutableList.reverse()\n    mutableList.removeLast()\n    mutableList.reverse()\n    return mutableList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [7, 8, 2, 8]) == [8, 2, 8])"
    },
    {
        "id": 418
    },
    {
        "id": 419,
        "code": "import Foundation\n\nfunc f(text: String, value: String) -> String {\n    if !text.contains(value) {\n        return \"\"\n    }\n    if let range = text.range(of: value, options: .backwards) {\n        return String(text[..<range.lowerBound])\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mmfbifen\", value: \"i\") == \"mmfb\")"
    },
    {
        "id": 420,
        "code": "import Foundation\n\nfunc f(text: String) -> Bool {\n    return text.rangeOfCharacter(from: CharacterSet.letters.inverted) == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"x\") == true)"
    },
    {
        "id": 421,
        "code": "\n/// \nfunc f(s: String, n: Int) -> String {\n    if s.count < n {\n        return s\n    } else {\n        return String(s.dropFirst(n))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"try.\", n: 5) == \"try.\")"
    },
    {
        "id": 422,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var new_array = array\n    new_array.reverse()\n    return new_array.map { $0 * $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 1]) == [1, 4, 1])"
    },
    {
        "id": 423,
        "code": "\n/// \nfunc f(selfie: [Int]) -> [Int] {\n    var selfie = selfie\n    let lo = selfie.count\n    for i in stride(from: lo-1, through: 0, by: -1) {\n        if selfie[i] == selfie[0] {\n            selfie.remove(at: lo-1)\n        }\n    }\n    return selfie\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(selfie: [4, 2, 5, 1, 3, 2, 6]) == [4, 2, 5, 1, 3, 2])"
    },
    {
        "id": 424
    },
    {
        "id": 425
    },
    {
        "id": 426,
        "code": "\n\n/// \nfunc f(numbers: [Int], elem: Int, idx: Int) -> [Int] {\n    guard idx < numbers.count else {\n        return numbers + [elem]\n    }\n    var newArray = numbers\n    newArray.insert(elem, at: idx)\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [1, 2, 3], elem: 8, idx: 5) == [1, 2, 3, 8])"
    },
    {
        "id": 427,
        "code": "func f(s: String) -> String {\n    var count = s.count - 1\n    var reverse_s = String(s.reversed())\n    \n    while count > 0, let range = reverse_s.enumerated().filter({ $0.offset % 2 == 0 && $0.element == \"s\" }).last {\n        count -= 1\n        reverse_s = String(reverse_s.prefix(count))\n    }\n    \n    let startIndex = reverse_s.index(reverse_s.startIndex, offsetBy: count)\n    return String(reverse_s.suffix(from: startIndex))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"s a a b s d s a a s a a\") == \"\")"
    },
    {
        "id": 428,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var result = nums\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result.append(result[i] * result[i + 1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 429
    },
    {
        "id": 430
    },
    {
        "id": 431,
        "code": "\n/// \nfunc f(n: Int, m: Int) -> [Int] {\n    var arr = Array(1...n)\n    for _ in 0..<m {\n        arr.removeAll()\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 1, m: 3) == [] as [Int])"
    },
    {
        "id": 432,
        "code": "\n\nextension Bool: Error {}\n\nfunc f(length: Int, text: String) -> Result<String, Bool> {\n    if text.count == length {\n        return .success(String(text.reversed()))\n    }\n    return .failure(false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(length: -5, text: \"G5ogb6f,c7e.EMm\") == .failure(false))"
    },
    {
        "id": 433,
        "code": "func f(text: String) -> String {\n    var textArray = text.split(separator: \",\")\n    textArray.removeFirst()\n    let indexOfT = textArray.firstIndex(of: \"T\")!\n    textArray.remove(at: indexOfT)\n    textArray.insert(\"T\", at: 0)\n    return \"T\" + \",\" + textArray.joined(separator: \",\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Dmreh,Sspp,T,G ,.tB,Vxk,Cct\") == \"T,T,Sspp,G ,.tB,Vxk,Cct\")"
    },
    {
        "id": 434,
        "code": "\n/// \nfunc f(string: String) -> Int {\n    if let lastIndex = string.lastIndex(of: \"e\") {\n        return string.distance(from: string.startIndex, to: lastIndex)\n    } else {\n        return -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"eeuseeeoehasa\") == 8)"
    },
    {
        "id": 435,
        "code": "func f(numbers: [String], num: Int, val: Int) -> String {\n    var numbers = numbers\n    let valStr = String(val)\n    \n    // Ensure num is greater than 0 to avoid division by zero\n    if num > 0 {\n        while numbers.count < num {\n            numbers.insert(valStr, at: numbers.count / 2)\n        }\n        \n        if num > 1 {\n            for _ in 0..<(numbers.count / (num - 1) - 4) {\n                numbers.insert(valStr, at: numbers.count / 2)\n            }\n        }\n    }\n    \n    return numbers.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [] as [String], num: 0, val: 1) == \"\")"
    },
    {
        "id": 436,
        "code": "\n/// \nfunc f(s: String, characters: [Int]) -> [String] {\n    return characters.map { index in\n        String(s[String.Index(utf16Offset: index, in: s)])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"s7 6s 1ss\", characters: [1, 3, 6, 1, 2]) == [\"7\", \"6\", \"1\", \"7\", \" \"])"
    },
    {
        "id": 437
    },
    {
        "id": 438
    },
    {
        "id": 439,
        "code": "func f(value: String) -> String {\n    let parts = value.split(separator: \" \").filter { String($0) != \"\" }\n    return parts.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(value: \"coscifysu\") == \"coscifysu\")"
    },
    {
        "id": 440,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    if text.rangeOfCharacter(from: CharacterSet.decimalDigits.inverted) == nil {\n        return \"yes\"\n    } else {\n        return \"no\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abc\") == \"no\")"
    },
    {
        "id": 441
    },
    {
        "id": 442,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var res: [Int] = []\n    \n    for num in lst {\n        if num % 2 == 0 {\n            res.append(num)\n        }\n    }\n    \n    return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [1, 2, 3, 4]) == [1, 2, 3, 4])"
    },
    {
        "id": 443,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    var newText = text.trimmingCharacters(in: .whitespacesAndNewlines)\n    if newText.contains(\"cd\") {\n        newText = newText.replacingOccurrences(of: \"cd\", with: \" \")\n    }\n    return newText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"lorem ipsum\") == \"lorem ipsum\")"
    },
    {
        "id": 444
    },
    {
        "id": 445
    },
    {
        "id": 446,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var newArray = array\n    let l = newArray.count\n    if l % 2 == 0 {\n        newArray.removeAll()\n    } else {\n        newArray.reverse()\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 447,
        "code": "\nimport Foundation\n\nfunc f(text: String, tab_size: Int) -> String {\n    var res = \"\"\n    let replacedText = text.replacingOccurrences(of: \"\\t\", with: String(repeating: \" \", count: tab_size-1))\n    for i in 0..<replacedText.count {\n        let char = replacedText[replacedText.index(replacedText.startIndex, offsetBy: i)]\n        if char == \" \" {\n            res += \"|\"\n        } else {\n            res += String(char)\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\\ta\", tab_size: 3) == \"||a\")"
    },
    {
        "id": 448,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> Bool {\n    if suffix == \"\" {\n        let suffix: String? = nil\n        return text.hasSuffix(suffix ?? \"\")\n    } else {\n        return text.hasSuffix(suffix)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"uMeGndkGh\", suffix: \"kG\") == false)"
    },
    {
        "id": 449,
        "code": "\n/// \nfunc f(x: String) -> Bool {\n    let n = x.count\n    var i = 0\n    while i < n && x[x.index(x.startIndex, offsetBy: i)].isNumber {\n        i += 1\n    }\n    return i == n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: \"1\") == true)"
    },
    {
        "id": 450,
        "code": "func f(strs: String) -> String {\n    var strs = strs.split(separator: \" \").map { String($0) }\n    for i in stride(from: 1, to: strs.count, by: 2) {\n        strs[i] = String(strs[i].reversed())\n    }\n    return strs.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strs: \"K zBK\") == \"K KBz\")"
    },
    {
        "id": 451,
        "code": "\n/// \nfunc f(text: String, char: String) -> String {\n    var textArray = Array(text)\n    for (index, item) in textArray.enumerated() {\n        if item == Character(char) {\n            textArray.remove(at: index)\n            return String(textArray)\n        }\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"pn\", char: \"p\") == \"n\")"
    },
    {
        "id": 452,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var counter = 0\n    for char in text {\n        if char.isLetter {\n            counter += 1\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"l000*\") == 1)"
    },
    {
        "id": 453,
        "code": "\n/// \nfunc f(string: String, c: String) -> Bool {\n    return string.hasSuffix(c)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"wrsch)xjmb8\", c: \"c\") == false)"
    },
    {
        "id": 454,
        "code": "\n/// \nfunc f(d: [String : AnyHashable], count: Int) -> [String : AnyHashable] {\n    var newDict: [String: AnyHashable] = [:]\n    for _ in 0..<count {\n        var tempDict = d\n        newDict.merge(tempDict) { (_, new) in new }\n    }\n    return newDict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"a\" : 2, \"b\" : [] as [AnyHashable], \"c\" : [:] as [AnyHashable : AnyHashable]], count: 0) == [:] as [String : AnyHashable])"
    },
    {
        "id": 455,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var uppers = 0\n    for c in text {\n        if c.isUppercase {\n            uppers += 1\n        }\n    }\n    \n    return uppers >= 10 ? text.uppercased() : text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"?XyZ\") == \"?XyZ\")"
    },
    {
        "id": 456,
        "code": "import Foundation\n\nfunc f(s: String, tab: Int) -> String {\n    return s.replacingOccurrences(of: \"\\t\", with: String(repeating: \" \", count: tab))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"Join us in Hungary\", tab: 4) == \"Join us in Hungary\")"
    },
    {
        "id": 457,
        "code": "func f(nums: [Int]) -> [Int] {\n    var nums = nums\n    var count = Array(0..<nums.count)\n    for i in 0..<nums.count {\n        nums.remove(at: 0)\n        if count.count > 0 {\n            count.remove(at: 0)\n        }\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 1, 7, 5, 6]) == [] as [Int])"
    },
    {
        "id": 458,
        "code": "\n\n/// \nfunc f(text: String, search_chars: String, replace_chars: String) -> String {\n    var trans_table: [Character: Character] = [:]\n    for i in 0..<min(search_chars.count, replace_chars.count) {\n        trans_table[search_chars[search_chars.index(search_chars.startIndex, offsetBy: i)]] = replace_chars[replace_chars.index(replace_chars.startIndex, offsetBy: i)]\n    }\n    var textArray = Array(text)\n    for (index, char) in textArray.enumerated() {\n        if let replacement = trans_table[char] {\n            textArray[index] = replacement\n        }\n    }\n    return String(textArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mmm34mIm\", search_chars: \"mm3\", replace_chars: \",po\") == \"pppo4pIp\")"
    },
    {
        "id": 459,
        "code": "\n\nfunc f(arr: [String], d: [String : String]) -> [String : String] {\n    var newDict = d\n    var i = 1\n    while i < arr.count {\n        newDict[arr[i]] = arr[i - 1]\n        i += 2\n    }\n    return newDict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(arr: [\"b\", \"vzjmc\", \"f\", \"ae\", \"0\"], d: [:] as [String : String]) == [\"vzjmc\" : \"b\", \"ae\" : \"f\"])"
    },
    {
        "id": 460,
        "code": "\n/// \nfunc f(text: String, amount: Int) -> String {\n    let length = text.count\n    var pre_text = \"|\"\n    if amount >= length {\n        let extraSpace = amount - length\n        pre_text += String(repeating: \" \", count: extraSpace / 2)\n        return pre_text + text + pre_text\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"GENERAL NAGOOR\", amount: 5) == \"GENERAL NAGOOR\")"
    },
    {
        "id": 461,
        "code": "\n/// \nfunc f(text: String, search: String) -> Bool {\n    return search.hasPrefix(text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"123\", search: \"123eenhas0\") == true)"
    },
    {
        "id": 462,
        "code": "func f(text: String, value: String) -> String {\n    let length = text.count\n    let letters = Array(text)\n    if !letters.contains(Character(value)) {\n        let newValue = String(letters[0])\n        return String(repeating: newValue, count: length)\n    }\n    return String(repeating: value, count: length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ldebgp o\", value: \"o\") == \"oooooooo\")"
    },
    {
        "id": 463,
        "code": "\n\n/// \nfunc f(dict: [Int : Int]) -> [Int : Int] {\n    var result = dict\n    dict.forEach { (k, v) in \n        if result.keys.contains(v) {\n            result.removeValue(forKey: k)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dict: [-1 : -1, 5 : 5, 3 : 6, -4 : -4]) == [3 : 6])"
    },
    {
        "id": 464,
        "code": "\nextension String: Error {}\n        \n/// \nfunc f(ans: String) -> Result<Int, String> {\n    if let total = Int(ans) {\n        var result = total * 4 - 50\n        result -= ans.filter { !\"02468\".contains($0) }.count * 100\n        return .success(result)\n    }\n    return .failure(\"NAN\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ans: \"0\") == .success(-50))"
    },
    {
        "id": 465
    },
    {
        "id": 466,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let length = text.count\n    var index = 0\n    while index < length && text[text.index(text.startIndex, offsetBy: index)].isWhitespace {\n        index += 1\n    }\n    return String(text[text.index(text.startIndex, offsetBy: index)..<text.index(text.startIndex, offsetBy: min(index+5, length))])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"-----\\t\\n\\tth\\n-----\") == \"-----\")"
    },
    {
        "id": 467
    },
    {
        "id": 468,
        "code": "\n\nimport Foundation\n\nfunc f(a: String, b: String, n: Int) -> String {\n    var result = b\n    var m = b\n    var mutableA = a\n    for _ in 0..<n {\n        if let range = mutableA.range(of: m) {\n            mutableA = mutableA.replacingOccurrences(of: m, with: \"\")\n            result = m\n            m = b\n        } else {\n            m = \"\"\n        }\n    }\n    return mutableA.components(separatedBy: b).joined(separator: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"unrndqafi\", b: \"c\", n: 2) == \"unrndqafi\")"
    },
    {
        "id": 469
    },
    {
        "id": 470
    },
    {
        "id": 471,
        "code": "func f(val: String, text: String) -> Int {\n    let indices = text.enumerated().compactMap { $0.element == val.first ? $0.offset : nil }\n    if indices.isEmpty {\n        return -1\n    } else {\n        return indices[0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(val: \"o\", text: \"fnmart\") == -1)"
    },
    {
        "id": 472,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> [Int] {\n    var d: [Character: Int] = [:]\n    for char in text.replacingOccurrences(of: \"-\", with: \"\").lowercased() {\n        d[char, default: 0] += 1\n    }\n    let sortedDict = d.sorted { $0.value < $1.value }\n    return sortedDict.map { $0.value }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"x--y-z-5-C\") == [1, 1, 1, 1, 1])"
    },
    {
        "id": 473,
        "code": "\n/// \nfunc f(text: String, value: String) -> String {\n    var indexes = [Int]()\n    for i in 0..<text.count {\n        if text[text.index(text.startIndex, offsetBy: i)] == Character(value) {\n            indexes.append(i)\n        }\n    }\n    var new_text = Array(text)\n    for i in indexes.reversed() {\n        new_text.remove(at: i)\n    }\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"scedvtvotkwqfoqn\", value: \"o\") == \"scedvtvtkwqfqn\")"
    },
    {
        "id": 474,
        "code": "import Foundation\n\nfunc f(txt: String, marker: Int) -> String {\n    var a: [String] = []\n    let lines = txt.split(separator: \"\\n\", omittingEmptySubsequences: false)\n    for line in lines {\n        a.append(String(line).center(marker))\n    }\n    return a.joined(separator: \"\\n\")\n}\n\nextension String {\n    func center(_ width: Int) -> String {\n        if width <= self.count {\n            return self\n        }\n        let totalPadding = width - self.count\n        let paddingLeft = totalPadding / 2\n        let paddingRight = totalPadding - paddingLeft\n        return String(repeating: \" \", count: paddingLeft) + self + String(repeating: \" \", count: paddingRight)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: \"#[)[]>[^e>\\n 8\", marker: -5) == \"#[)[]>[^e>\\n 8\")"
    },
    {
        "id": 475,
        "code": "\n\n/// \nfunc f(array: [Int], index: Int) -> Int {\n    var newIndex = index\n    if newIndex < 0 {\n        newIndex = array.count + newIndex\n    }\n    return array[newIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1], index: 0) == 1)"
    },
    {
        "id": 476,
        "code": "\n/// \nfunc f(a: String, split_on: String) -> Bool {\n    let t = a.split(separator: \" \")\n    var a = [String]()\n    \n    for i in t {\n        for j in i {\n            a.append(String(j))\n        }\n    }\n    \n    if a.contains(split_on) {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: \"booty boot-boot bootclass\", split_on: \"k\") == false)"
    },
    {
        "id": 477,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> (String, String) {\n    let components = text.split(separator: \"|\").map { String($0) }\n    var topic = components.dropLast().joined(separator: \"|\")\n    var problem = components.last ?? \"\"\n    \n    if problem == \"r\" {\n        let topicMutable = NSMutableString(string: topic)\n        topic = topicMutable.replacingOccurrences(of: \"u\", with: \"p\") as String\n    }\n    \n    return (topic, problem)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"|xduaisf\") == (\"\", \"xduaisf\"))"
    },
    {
        "id": 478,
        "code": "\n/// \nfunc f(sb: String) -> [String : Int] {\n    var d = [String: Int]()\n    for s in sb {\n        d[String(s)] = d[String(s), default: 0] + 1\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(sb: \"meow meow\") == [\"m\" : 2, \"e\" : 2, \"o\" : 2, \"w\" : 2, \" \" : 1])"
    },
    {
        "id": 479,
        "code": "\n/// \nfunc f(nums: [Int], pop1: Int, pop2: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.remove(at: pop1 - 1)\n    updatedNums.remove(at: pop2 - 1)\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 5, 2, 3, 6], pop1: 2, pop2: 4) == [1, 2, 3])"
    },
    {
        "id": 480,
        "code": "import Foundation\n\nfunc f(s: String, c1: String, c2: String) -> String {\n    if s.isEmpty {\n        return s\n    }\n    var ls = s.components(separatedBy: c1)\n    for (index, item) in ls.enumerated() {\n        if item.contains(c1) {\n            if let range = item.range(of: c1) {\n                ls[index] = item.replacingCharacters(in: range, with: c2)\n            }\n        }\n    }\n    return ls.joined(separator: c1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"\", c1: \"mi\", c2: \"siast\") == \"\")"
    },
    {
        "id": 481,
        "code": "func f(values: [Int], item1: Int, item2: Int) -> [Int] {\n    var updatedValues = values\n    if let firstValue = updatedValues.first, updatedValues.last == item2 {\n        if !updatedValues.dropFirst().contains(firstValue) {\n            updatedValues.append(firstValue)\n        }\n    } else if updatedValues.last == item1 {\n        if let firstValue = updatedValues.first, firstValue == item2 {\n            updatedValues.append(firstValue)\n        }\n    }\n    return updatedValues\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(values: [1, 1], item1: 2, item2: 3) == [1, 1])"
    },
    {
        "id": 482,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    return text.replacingOccurrences(of: \"\", with: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Because it intrigues them\") == \"Because it intrigues them\")"
    },
    {
        "id": 483
    },
    {
        "id": 484
    },
    {
        "id": 485
    },
    {
        "id": 486,
        "code": "\n/// \nfunc f(dic: [Int : Int]) -> [Int : Int] {\n    var dic_op = dic\n    for (key, val) in dic {\n        dic_op[key] = val * val\n    }\n    return dic_op\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dic: [1 : 1, 2 : 2, 3 : 3]) == [1 : 1, 2 : 4, 3 : 9])"
    },
    {
        "id": 487,
        "code": "\n/// \nfunc f(dict: [Int : String]) -> [Int] {\n    var evenKeys: [Int] = []\n    for key in dict.keys {\n        if key % 2 == 0 {\n            evenKeys.append(key)\n        }\n    }\n    return evenKeys\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dict: [4 : \"a\"]) == [4])"
    },
    {
        "id": 488
    },
    {
        "id": 489,
        "code": "func f(text: String, value: String) -> String {\n    if text.lowercased().hasPrefix(value.lowercased()) {\n        return String(text.dropFirst(value.count))\n    } else {\n        return text\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"coscifysu\", value: \"cos\") == \"cifysu\")"
    },
    {
        "id": 490
    },
    {
        "id": 491,
        "code": "\n\n/// \nfunc f(xs: [Int]) -> [Int] {\n    var xs = xs\n    for i in 0..<xs.count {\n        let reverseIndex = xs.count - i - 1\n        xs.append(contentsOf: [xs[reverseIndex], xs[reverseIndex]])\n    }\n    return xs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(xs: [4, 8, 8, 5]) == [4, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5])"
    },
    {
        "id": 492,
        "code": "\n/// \nfunc f(text: String, value: String) -> String {\n    var ls = Array(text)\n    if ls.filter({ $0 == Character(value) }).count % 2 == 0 {\n        while ls.contains(Character(value)) {\n            if let index = ls.firstIndex(of: Character(value)) {\n                ls.remove(at: index)\n            }\n        }\n    } else {\n        ls.removeAll()\n    }\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abbkebaniuwurzvr\", value: \"m\") == \"abbkebaniuwurzvr\")"
    },
    {
        "id": 493
    },
    {
        "id": 494,
        "code": "func f(num: String, l: Int) -> String {\n    var t = \"\"\n    var remainingLength = l\n    while remainingLength > num.count {\n        t += \"0\"\n        remainingLength -= 1\n    }\n    return t + num\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: \"1\", l: 3) == \"001\")"
    },
    {
        "id": 495
    },
    {
        "id": 496,
        "code": "\n/// \nfunc f(text: String, value: String) -> Int {\n    if let _ = value as? String {\n        return text.filter { $0.lowercased() == value.lowercased() }.count\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"eftw{ьТсk_1\", value: \"\\\\\") == 0)"
    },
    {
        "id": 497
    },
    {
        "id": 498,
        "code": "\n/// \nfunc f(nums: [Int], idx: Int, added: Int) -> [Int] {\n    var updatedNums = nums\n    updatedNums.insert(added, at: idx)\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 2, 2, 3, 3], idx: 2, added: 3) == [2, 2, 3, 2, 3, 3])"
    },
    {
        "id": 499
    },
    {
        "id": 500,
        "code": "\n/// \nfunc f(text: String, delim: String) -> String {\n    return String(text.prefix(text.reversed().firstIndex(of: Character(delim))!).reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"dsj osq wi w\", delim: \" \") == \"d\")"
    },
    {
        "id": 501
    },
    {
        "id": 502,
        "code": "func f(name: String) -> String {\n    return name.split(separator: \" \").joined(separator: \"*\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(name: \"Fred Smith\") == \"Fred*Smith\")"
    },
    {
        "id": 503
    },
    {
        "id": 504,
        "code": "\n/// \nfunc f(values: [Int]) -> [Int] {\n    var sortedValues = values\n    sortedValues.sort()\n    return sortedValues\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(values: [1, 1, 1, 1]) == [1, 1, 1, 1])"
    },
    {
        "id": 505,
        "code": "\n/// \nfunc f(string: String) -> String {\n    var str = string\n    while !str.isEmpty {\n        if str.last!.isLetter {\n            return str\n        }\n        str.removeLast()\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"--4/0-209\") == \"\")"
    },
    {
        "id": 506,
        "code": "\n/// \nfunc f(n: Int) -> String {\n    var p = \"\"\n    if n % 2 == 1 {\n        p += \"sn\"\n    } else {\n        return String(n * n)\n    }\n    for x in 1...n {\n        if x % 2 == 0 {\n            p += \"to\"\n        } else {\n            p += \"ts\"\n        }\n    }\n    return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 1) == \"snts\")"
    },
    {
        "id": 507,
        "code": "import Foundation\n\nfunc f(text: String, search: String) -> Int {\n    let result = text.lowercased()\n    return result.range(of: search.lowercased())?.lowerBound.utf16Offset(in: result) ?? -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"car hat\", search: \"car\") == 0)"
    },
    {
        "id": 508
    },
    {
        "id": 509,
        "code": "func f(value: Int, width: Int) -> String {\n    if value >= 0 {\n        return String(repeating: \"0\", count: max(0, width - String(value).count)) + String(value)\n    }\n    \n    if value < 0 {\n        let absValue = -value\n        return \"-\" + String(repeating: \"0\", count: max(0, width - 1 - String(absValue).count)) + String(absValue)\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(value: 5, width: 1) == \"5\")"
    },
    {
        "id": 510
    },
    {
        "id": 511
    },
    {
        "id": 512,
        "code": "\n/// \nfunc f(s: String) -> Bool {\n    return s.count == s.filter({ $0 == \"0\" || $0 == \"1\" }).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"102\") == false)"
    },
    {
        "id": 513,
        "code": "\n\nfunc f(array: [Int]) -> [Int] {\n    var array = array\n    while array.contains(-1) {\n        if array.count > 2 { array.remove(at: array.index(array.endIndex, offsetBy: -3)) }\n    }\n    while array.contains(0) { array.popLast() }\n    while array.contains(1) { array.removeFirst() }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [0, 2]) == [] as [Int])"
    },
    {
        "id": 514
    },
    {
        "id": 515,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var result = array\n    result.reverse()\n    result = result.map { $0 * 2 }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 3, 4, 5]) == [10, 8, 6, 4, 2])"
    },
    {
        "id": 516,
        "code": "\n/// \nfunc f(strings: [String], substr: String) -> [String] {\n    let list = strings.filter { $0.hasPrefix(substr) }\n    return list.sorted { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(strings: [\"condor\", \"eyes\", \"gay\", \"isa\"], substr: \"d\") == [] as [String])"
    },
    {
        "id": 517,
        "code": "\n/// \nfunc f(text: String) -> String {\n    for i in (0..<text.count).reversed() {\n        let index = text.index(text.startIndex, offsetBy: i)\n        if !text[index].isUppercase {\n            return String(text[..<index])\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"SzHjifnzog\") == \"SzHjifnzo\")"
    },
    {
        "id": 518,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return !text.isEmpty && Int(text) == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"the speed is -36 miles per hour\") == true)"
    },
    {
        "id": 519,
        "code": "\n\nfunc f(d: [String: Int]) -> [Int: Bool] {\n    var mutableD = d\n    mutableD[\"luck\"] = 42\n    mutableD.removeAll()\n    return [1: false, 2: true]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [:] as [String : Int]) == [1 : false, 2 : true])"
    },
    {
        "id": 520,
        "code": "\n/// \nfunc f(album_sales: [Int]) -> Int {\n    var sales = album_sales\n    while sales.count != 1 {\n        sales.append(sales.removeFirst())\n    }\n    return sales[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(album_sales: [6]) == 6)"
    },
    {
        "id": 521,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    let m = nums.max() ?? 0\n    for _ in 0..<m {\n        nums.reverse()\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [43, 0, 4, 77, 5, 2, 0, 9, 77]) == [77, 9, 0, 2, 5, 77, 4, 0, 43])"
    },
    {
        "id": 522,
        "code": "\n\n/// \nfunc f(numbers: [Int]) -> [Double] {\n    let floats = numbers.map{ Double($0 % 1) }\n    return floats.contains(1) ? floats : []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]) == [] as [Double])"
    },
    {
        "id": 523,
        "code": "func f(text: String) -> String {\n    var textArray = Array(text)\n    for i in stride(from: textArray.count - 1, through: 0, by: -1) {\n        if textArray[i].isWhitespace {\n            textArray[i] = \"&\"\n            textArray.insert(contentsOf: \"nbsp;\", at: i+1)\n        }\n    }\n    return String(textArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"   \") == \"&nbsp;&nbsp;&nbsp;\")"
    },
    {
        "id": 524
    },
    {
        "id": 525,
        "code": "\n/// \nfunc f(c: [String : Int], st: Int, ed: Int) -> (String, String) {\n    var d = [Int: String]()\n    var a = \"\"\n    var b = \"\"\n    for (x, y) in c {\n        d[y] = x\n        if y == st {\n            a = x\n        }\n        if y == ed {\n            b = x\n        }\n    }\n    let w = d[st] ?? \"\"\n    return a > b ? (w, b) : (b, w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(c: [\"TEXT\" : 7, \"CODE\" : 3], st: 7, ed: 3) == (\"TEXT\", \"CODE\"))"
    },
    {
        "id": 526,
        "code": "func f(label1: String, char: Character, label2: String, index: Int) -> String {\n    if let m = label1.lastIndex(of: char) {\n        let mIndex = label1.distance(from: label1.startIndex, to: m)\n        if mIndex >= index {\n            return String(label2.prefix(mIndex - index + 1))\n        }\n        let newIndex = label1.count + index - mIndex - 1\n        return label1 + String(label2.suffix(from: label2.index(label2.startIndex, offsetBy: newIndex)))\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(label1: \"ekwies\", char: \"s\", label2: \"rpg\", index: 1) == \"rpg\")"
    },
    {
        "id": 527
    },
    {
        "id": 528
    },
    {
        "id": 529,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var prev = array[0]\n    var newArray = array\n    var i = 1\n    while i < newArray.count {\n        if prev != newArray[i] {\n            newArray[i] = newArray[i]\n        } else {\n            newArray.remove(at: i)\n            i -= 1\n        }\n        prev = newArray[i]\n        i += 1\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 3]) == [1, 2, 3])"
    },
    {
        "id": 530,
        "code": "import Foundation\n\nfunc f(s: String, ch: String) -> String {\n    var sl = s\n    if s.contains(ch.first ?? Character(\"\")) {\n        sl = s.trimmingCharacters(in: CharacterSet(charactersIn: ch))\n        if sl.isEmpty {\n            sl += \"!?\"\n        }\n    } else {\n        return \"no\"\n    }\n    return sl\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"@@@ff\", ch: \"@\") == \"ff\")"
    },
    {
        "id": 531,
        "code": "import Foundation\n\nfunc f(text: String, x: String) -> String {\n    if text.hasPrefix(x) {\n        return text\n    } else {\n        let newText = String(text.dropFirst())\n        return f(text: newText, x: x)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Ibaskdjgblw asdl \", x: \"djgblw\") == \"djgblw asdl \")"
    },
    {
        "id": 532,
        "code": "\n/// \nfunc f(n: Int, array: [Int]) -> [[Int]] {\n    var final: [[Int]] = [array] \n    for _ in 0..<n {\n        var arr = array\n        arr.append(contentsOf: final.last!)\n        final.append(arr)\n    }\n    return final\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 1, array: [1, 2, 3]) == [[1, 2, 3], [1, 2, 3, 1, 2, 3]])"
    },
    {
        "id": 533,
        "code": "\n/// \nfunc f(query: String, base: [String : Int]) -> Int {\n    var net_sum = 0\n    for (key, val) in base {\n        if key.first == Character(query) && key.count == 3 {\n            net_sum -= val\n        } else if key.last == Character(query) && key.count == 3 {\n            net_sum += val\n        }\n    }\n    return net_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(query: \"a\", base: [:] as [String : Int]) == 0)"
    },
    {
        "id": 534,
        "code": "import Foundation\n\nfunc f(sequence: String, value: String) -> String {\n    guard let valueIndex = sequence.firstIndex(of: Character(value)) else {\n        return sequence\n    }\n    \n    let index = max(sequence.distance(from: sequence.startIndex, to: valueIndex) - sequence.count / 3, 0)\n    let startIndex = sequence.index(sequence.startIndex, offsetBy: index)\n    \n    var result = \"\"\n    for (j, v) in sequence[startIndex...].enumerated() {\n        if v == \"+\" {\n            result += value\n        } else {\n            result += String(v)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(sequence: \"hosu\", value: \"o\") == \"hosu\")"
    },
    {
        "id": 535,
        "code": "\n/// \nfunc f(n: Int) -> Bool {\n    for digit in String(n) {\n        if digit != \"0\" && digit != \"1\" && !(5...9).contains(Int(String(digit)) ?? 0) {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 1341240312) == false)"
    },
    {
        "id": 536,
        "code": "\n/// \nfunc f(cat: String) -> Int {\n    var digits = 0\n    for char in cat {\n        if char.isNumber {\n            digits += 1\n        }\n    }\n    return digits\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(cat: \"C24Bxxx982ab\") == 5)"
    },
    {
        "id": 537,
        "code": "\n/// \nfunc f(text: String, value: String) -> String {\n    var new_text = Array(text)\n    do {\n        new_text.append(Character(value))\n        let length = new_text.count\n        return \"[\" + String(length) + \"]\"\n    } catch {\n        return \"[0]\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abv\", value: \"a\") == \"[4]\")"
    },
    {
        "id": 538
    },
    {
        "id": 539
    },
    {
        "id": 540,
        "code": "\n/// \nfunc f(a: [Int]) -> [Int] {\n    var b = a\n    var k = 0\n    while k < (a.count - 1) {\n        b.insert(b[k], at: k + 1)\n        k += 2\n    }\n    b.append(b[0])\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: [5, 5, 5, 6, 4, 9]) == [5, 5, 5, 5, 5, 5, 6, 4, 9, 5])"
    },
    {
        "id": 541,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return text.filter{ !$0.isWhitespace }.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \" \\t  　\") == true)"
    },
    {
        "id": 542
    },
    {
        "id": 543,
        "code": "import Foundation\n\nfunc f(item: String) -> String {\n    var modified = item.replacingOccurrences(of: \". \", with: \" , \")\n    modified = modified.replacingOccurrences(of: \"&#33; \", with: \"! \")\n    modified = modified.replacingOccurrences(of: \". \", with: \"? \")\n    modified = modified.replacingOccurrences(of: \". \", with: \". \")\n    \n    if let first = modified.first {\n        modified = first.uppercased() + modified.dropFirst()\n    }\n    \n    return modified\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(item: \".,,,,,. منبت\") == \".,,,,, , منبت\")"
    },
    {
        "id": 544,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    let a = text.components(separatedBy: \"\\n\")\n    var b = [String]()\n    for i in 0..<a.count {\n        let c = a[i].replacingOccurrences(of: \"\\t\", with: \"    \")\n        b.append(c)\n    }\n    return b.joined(separator: \"\\n\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\\t\\t\\ttab tab tabulates\") == \"            tab tab tabulates\")"
    },
    {
        "id": 545,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var result: [Int] = []\n    var index = 0\n    var tempArray = array\n\n    while index < tempArray.count {\n        result.append(tempArray.removeLast())\n        index += 2\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [8, 8, -4, -9, 2, 8, -1, 8]) == [8, -1, 8])"
    },
    {
        "id": 546,
        "code": "\n/// \nfunc f(text: String, speaker: String) -> String {\n    var updatedText = text\n    while updatedText.hasPrefix(speaker) {\n        updatedText = String(updatedText.dropFirst(speaker.count))\n    }\n    return updatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"[CHARRUNNERS]Do you know who the other was? [NEGMENDS]\", speaker: \"[CHARRUNNERS]\") == \"Do you know who the other was? [NEGMENDS]\")"
    },
    {
        "id": 547,
        "code": "import Foundation\n\nfunc f(letters: String) -> String {\n    let lettersOnly = letters.trimmingCharacters(in: CharacterSet(charactersIn: \".,!?*\"))\n    return lettersOnly.components(separatedBy: \" \").joined(separator: \"....\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(letters: \"h,e,l,l,o,wo,r,ld,\") == \"h,e,l,l,o,wo,r,ld\")"
    },
    {
        "id": 548,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    if !suffix.isEmpty && !text.isEmpty && text.hasSuffix(suffix) {\n        return String(text.prefix(text.count - suffix.count))\n    } else {\n        return text\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"spider\", suffix: \"ed\") == \"spider\")"
    },
    {
        "id": 549,
        "code": "\n/// \nfunc f(matrix: [[Int]]) -> [[Int]] {\n    var reversedMatrix = matrix.reversed()\n    var result: [[Int]] = []\n    for var primary in reversedMatrix {\n        primary.sort(by: >)\n        result.append(primary)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(matrix: [[1, 1, 1, 1]]) == [[1, 1, 1, 1]])"
    },
    {
        "id": 550,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var modifiedNums = nums\n    for i in 0..<modifiedNums.count {\n        modifiedNums.insert(modifiedNums[i] * modifiedNums[i], at: i)\n    }\n    return modifiedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 4]) == [1, 1, 1, 1, 2, 4])"
    },
    {
        "id": 551,
        "code": "\n/// \nfunc f(data: [String : [String]]) -> [String] {\n    var members: [String] = []\n    for (_, values) in data {\n        for member in values {\n            if !members.contains(member) {\n                members.append(member)\n            }\n        }\n    }\n    return members.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(data: [\"inf\" : [\"a\", \"b\"], \"a\" : [\"inf\", \"c\"], \"d\" : [\"inf\"]]) == [\"a\", \"b\", \"c\", \"inf\"])"
    },
    {
        "id": 552
    },
    {
        "id": 553,
        "code": "\n/// \nfunc f(text: String, count: Int) -> String {\n    var text = text\n    for _ in 0..<count {\n        text = String(text.reversed())\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"439m2670hlsw\", count: 3) == \"wslh0762m934\")"
    },
    {
        "id": 554,
        "code": "\n/// \nfunc f(arr: [Int]) -> [Int] {\n    return arr.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(arr: [2, 0, 1, 9999, 3, -5]) == [-5, 3, 9999, 1, 0, 2])"
    },
    {
        "id": 555,
        "code": "\nimport Foundation\n\nfunc f(text: String, tabstop: Int) -> String {\n    let newLine = \"_____\"\n    var newText = text\n        .replacingOccurrences(of: \"\\n\", with: newLine)\n        .replacingOccurrences(of: \"\\t\", with: String(repeating: \" \", count: tabstop))\n        .replacingOccurrences(of: newLine, with: \"\\n\")\n    return newText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"odes\\tcode\\twell\", tabstop: 2) == \"odes  code  well\")"
    },
    {
        "id": 556
    },
    {
        "id": 557,
        "code": "import Foundation\n\nfunc f(s: String) -> String {\n    if let range = s.range(of: \"ar\", options: .backwards) {\n        let before = s[..<range.lowerBound]\n        let match = s[range]\n        let after = s[range.upperBound...]\n        return \"\\(before) \\(match) \\(after)\"\n    } else {\n        return s\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"xxxarmmarxx\") == \"xxxarmm ar xx\")"
    },
    {
        "id": 558,
        "code": "\n/// \nfunc f(nums: [Int], mos: [Int]) -> Bool {\n    var numsCopy = nums\n    for num in mos {\n        numsCopy.remove(at: numsCopy.firstIndex(of: num)!)\n    }\n    numsCopy.sort()\n    for num in mos {\n        numsCopy.append(num)\n    }\n    for i in 0..<(numsCopy.count - 1) {\n        if numsCopy[i] > numsCopy[i + 1] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 1, 2, 1, 4, 1], mos: [1]) == false)"
    },
    {
        "id": 559,
        "code": "import Foundation\n\nfunc f(n: String) -> String {\n    let firstChar = n.prefix(1)\n    let rest = String(n.dropFirst()).replacingOccurrences(of: \"-\", with: \"_\")\n    return firstChar + \".\" + rest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: \"first-second-third\") == \"f.irst_second_third\")"
    },
    {
        "id": 560
    },
    {
        "id": 561,
        "code": "\n/// \nfunc f(text: String, digit: String) -> Int {\n    let count = text.filter { String($0) == digit }.count\n    return Int(digit)! * count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"7Ljnw4Lj\", digit: \"7\") == 7)"
    },
    {
        "id": 562,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    return text.uppercased() == text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"VTBAEPJSLGAHINS\") == true)"
    },
    {
        "id": 563,
        "code": "\n/// \nfunc f(text1: String, text2: String) -> Int {\n    var nums: [Int] = []\n    for i in 0..<text2.count {\n        nums.append(text1.filter { $0 == text2[text2.index(text2.startIndex, offsetBy: i)] }.count)\n    }\n    return nums.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text1: \"jivespdcxc\", text2: \"sx\") == 2)"
    },
    {
        "id": 564,
        "code": "func f(lists: [[Int]]) -> [Int] {\n    var mutableLists = lists\n    mutableLists[1].removeAll()\n    mutableLists[2].append(contentsOf: mutableLists[1])\n    return mutableLists[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lists: [[395, 666, 7, 4], [] as [Int], [4223, 111]]) == [395, 666, 7, 4])"
    },
    {
        "id": 565,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    return text.compactMap { char in \"aeiou\".contains(char) ? text.firstIndex(of: char)?.utf16Offset(in: text) : nil }.max() ?? -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"qsqgijwmmhbchoj\") == 13)"
    },
    {
        "id": 566,
        "code": "import Foundation\n\nfunc f(string: String, code: String) -> String {\n    var t = \"\"\n    do {\n        if let data = string.data(using: .utf8) {\n            t = String(data: data, encoding: .utf8) ?? \"\"\n            if t.hasSuffix(\"\\n\") {\n                t.removeLast()\n            }\n        }\n    } catch {\n        return t\n    }\n    return t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"towaru\", code: \"UTF-8\") == \"towaru\")"
    },
    {
        "id": 567,
        "code": "func f(s: String, n: Int) -> [String] {\n    let ls = s.split(separator: \" \").map { String($0) }\n    var out: [String] = []\n    var lsCopy = ls\n    while lsCopy.count >= n {\n        out.append(contentsOf: Array(lsCopy.suffix(n)))\n        lsCopy = Array(lsCopy.dropLast(n))\n    }\n    return lsCopy + [\"\\(out.joined(separator: \"_\"))\"]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"one two three four five\", n: 3) == [\"one\", \"two\", \"three_four_five\"])"
    },
    {
        "id": 568
    },
    {
        "id": 569,
        "code": "\n/// \nfunc f(txt: String) -> Int {\n    var coincidences = [Character: Int]()\n    for c in txt {\n        if let count = coincidences[c] {\n            coincidences[c] = count + 1\n        } else {\n            coincidences[c] = 1\n        }\n    }\n    return coincidences.values.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: \"11 1 1\") == 6)"
    },
    {
        "id": 570,
        "code": "\n/// \nfunc f(array: [Int], index: Int, value: Int) -> [Int] {\n    var newArray = array\n    newArray.insert(index + 1, at: 0)\n    if value >= 1 {\n        newArray.insert(value, at: index)\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [2], index: 0, value: 2) == [2, 1, 2])"
    },
    {
        "id": 571,
        "code": "import Foundation\n\nfunc f(input_string: String, spaces: Int) -> String {\n    let tabWidth = spaces\n    let tabReplacement = String(repeating: \" \", count: tabWidth)\n    return (input_string as NSString).replacingOccurrences(of: \"\\t\", with: tabReplacement)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(input_string: \"a\\\\tb\", spaces: 4) == \"a\\\\tb\")"
    },
    {
        "id": 572
    },
    {
        "id": 573,
        "code": "\n/// \nfunc f(string: String, prefix: String) -> String {\n    if string.hasPrefix(prefix) {\n        return String(string.dropFirst(prefix.count))\n    }\n    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"Vipra\", prefix: \"via\") == \"Vipra\")"
    },
    {
        "id": 574,
        "code": "func f(simpons: [String]) -> String {\n    var simpons = simpons\n    while !simpons.isEmpty {\n        let pop = simpons.removeLast()\n        if pop == pop.prefix(1).uppercased() + pop.dropFirst() {\n            return pop\n        }\n    }\n    return simpons.last ?? \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(simpons: [\"George\", \"Michael\", \"George\", \"Costanza\"]) == \"Costanza\")"
    },
    {
        "id": 575,
        "code": "\n/// \nfunc f(nums: [Int], val: Int) -> Int {\n    var new_list: [Int] = []\n    nums.forEach { num in\n        new_list += Array(repeating: num, count: val)\n    }\n    return new_list.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [10, 4], val: 3) == 42)"
    },
    {
        "id": 576,
        "code": "\nfunc f(array: [Int], const: Int) -> [String] {\n    var output: [String] = [\"x\"]\n    for i in 1...array.count {\n        if i % 2 != 0 {\n            output.append(String(-2 * array[i - 1]))\n        } else {\n            output.append(String(const))\n        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 2, 3], const: -1) == [\"x\", \"-2\", \"-1\", \"-6\"])"
    },
    {
        "id": 577,
        "code": "\n/// \nfunc f(items: [(AnyHashable, AnyHashable)]) -> [[AnyHashable : AnyHashable]] {\n    var result: [[AnyHashable: AnyHashable]] = []\n    var items = items\n    \n    for item in items {\n        var d = Dictionary(uniqueKeysWithValues: items).filter { $0.key != item.0 }\n        result.append(d)\n        items = Array(d)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(items: [(1, \"pos\")]) == [[:] as [Int : Int]])"
    },
    {
        "id": 578,
        "code": "\n/// \nfunc f(obj: [String : Int]) -> [String : Int] {\n    var updatedObj = obj\n    for (key, value) in updatedObj {\n        if value >= 0 {\n            updatedObj[key] = -value\n        }\n    }\n    return updatedObj\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(obj: [\"R\" : 0, \"T\" : 3, \"F\" : -6, \"K\" : 0]) == [\"R\" : 0, \"T\" : -3, \"F\" : -6, \"K\" : 0])"
    },
    {
        "id": 579,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    if text.capitalized == text {\n        if text.count > 1 && text.lowercased() != text {\n            return text.prefix(1).lowercased() + text.dropFirst()\n        }\n    } else if text.rangeOfCharacter(from: CharacterSet.letters) != nil {\n        return text.capitalized\n    }\n    \n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\") == \"\")"
    },
    {
        "id": 580,
        "code": "func f(text: String, char: String) -> [Int] {\n    var new_text = text\n    var a: [Int] = []\n    while new_text.contains(Character(char)) {\n        if let index = new_text.firstIndex(of: Character(char)) {\n            a.append(new_text.distance(from: new_text.startIndex, to: index))\n            new_text.remove(at: index)\n        }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"rvr\", char: \"r\") == [0, 1])"
    },
    {
        "id": 581
    },
    {
        "id": 582,
        "code": "\n/// \nfunc f(k: Int, j: Int) -> [Int] {\n    var arr = [Int]()\n    for _ in 0..<k {\n        arr.append(j)\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(k: 7, j: 5) == [5, 5, 5, 5, 5, 5, 5])"
    },
    {
        "id": 583,
        "code": "\n/// \nfunc f(text: String, ch: String) -> String {\n    var result = [String]()\n    let lines = text.split(separator: \"\\n\")\n    \n    for line in lines {\n        if line.count > 0 && line.first == Character(ch) {\n            result.append(line.lowercased())\n        } else {\n            result.append(line.uppercased())\n        }\n    }\n    \n    return result.joined(separator: \"\\n\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"t\\nza\\na\", ch: \"t\") == \"t\\nZA\\nA\")"
    },
    {
        "id": 584,
        "code": "import Foundation\n\nfunc f(txt: String) -> String {\n    let zeros = String(repeating: \"0\", count: 20)\n    return String(format: txt, arguments: [zeros])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: \"5123807309875480094949830\") == \"5123807309875480094949830\")"
    },
    {
        "id": 585,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var count = text.filter({$0 == text.first}).count\n    var ls = Array(text)\n    for _ in 0..<count {\n        ls.removeFirst()\n    }\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \";,,,?\") == \",,,?\")"
    },
    {
        "id": 586,
        "code": "func f(text: String, char: String) -> Int {\n    if let index = text.lastIndex(of: Character(char)) {\n        return text.distance(from: text.startIndex, to: index)\n    } else {\n        return -1 // or any other appropriate value to indicate character not found\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"breakfast\", char: \"e\") == 2)"
    },
    {
        "id": 587,
        "code": "\n\nfunc f(nums: [Int], fill: String) -> [Int : String] {\n    var ans: [Int : String] = [:]\n    for num in nums {\n        ans[num] = fill\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [0, 1, 1, 2], fill: \"abcca\") == [0 : \"abcca\", 1 : \"abcca\", 2 : \"abcca\"])"
    },
    {
        "id": 588,
        "code": "\n/// \nfunc f(items: [String], target: String) -> Int {\n    if let index = items.firstIndex(of: target) {\n        return index\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(items: [\"1\", \"+\", \"-\", \"**\", \"//\", \"*\", \"+\"], target: \"**\") == 3)"
    },
    {
        "id": 589,
        "code": "\n/// \nfunc f(num: [Int]) -> [Int] {\n    var updatedNum = num\n    updatedNum.append(num.last ?? 0)\n    return updatedNum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: [-70, 20, 9, 1]) == [-70, 20, 9, 1, 1])"
    },
    {
        "id": 590,
        "code": "/// \nfunc f(text: String) -> String {\n    var updatedText = text\n    for i in (0...9).reversed() {\n        let charToRemove = Character(String(i))\n        while updatedText.first == charToRemove {\n            updatedText.removeFirst()\n        }\n    }\n    return updatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"25000   $\") == \"5000   $\")"
    },
    {
        "id": 591
    },
    {
        "id": 592,
        "code": "\n/// \nfunc f(numbers: [Int]) -> [Int] {\n    var newNumbers: [Int] = []\n    for i in 0..<numbers.count {\n        newNumbers.append(numbers[numbers.count - 1 - i])\n    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [11, 3]) == [3, 11])"
    },
    {
        "id": 593,
        "code": "func f(nums: [Int], n: Int) -> [Int] {\n    var mutableNums = nums\n    var pos = mutableNums.count - 1\n    for i in stride(from: -mutableNums.count, to: 0, by: 1) {\n        mutableNums.insert(mutableNums[i], at: pos)\n    }\n    return mutableNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [] as [Int], n: 14) == [] as [Int])"
    },
    {
        "id": 594,
        "code": "func f(file: String) -> Int {\n    if let index = file.firstIndex(of: \"\\n\") {\n        return file.distance(from: file.startIndex, to: index)\n    } else {\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(file: \"n wez szize lnson tilebi it 504n.\\n\") == 33)"
    },
    {
        "id": 595,
        "code": "func f(text: String, prefix: String) -> String {\n    var newText = text\n    if newText.hasPrefix(prefix) {\n        newText = String(newText.dropFirst(prefix.count))\n    }\n    newText = newText.prefix(1).uppercased() + newText.dropFirst()\n    return newText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"qdhstudentamxupuihbuztn\", prefix: \"jdm\") == \"Qdhstudentamxupuihbuztn\")"
    },
    {
        "id": 596,
        "code": "\n/// \nfunc f(txt: [String], alpha: String) -> [String] {\n    var txt = txt.sorted()\n    if let index = txt.firstIndex(of: alpha), index % 2 == 0 {\n        return txt.reversed()\n    }\n    return txt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(txt: [\"8\", \"9\", \"7\", \"4\", \"3\", \"2\"], alpha: \"9\") == [\"2\", \"3\", \"4\", \"7\", \"8\", \"9\"])"
    },
    {
        "id": 597,
        "code": "\n/// \nfunc f(s: String) -> String {\n    return s.uppercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"Jaafodsfa SOdofj AoaFjIs  JAFasIdfSa1\") == \"JAAFODSFA SODOFJ AOAFJIS  JAFASIDFSA1\")"
    },
    {
        "id": 598,
        "code": "\n/// \nfunc f(text: String, n: Int) -> String {\n    let length = text.count\n    return String(text[text.index(text.startIndex, offsetBy: length*(n%4))..<text.endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abc\", n: 1) == \"\")"
    },
    {
        "id": 599
    },
    {
        "id": 600,
        "code": "\n/// \nfunc f(array: [Int]) -> [String] {\n    let just_ns = array.map({String(repeating: \"n\", count: $0)})\n    var final_output: [String] = []\n    for wipe in just_ns {\n        final_output.append(wipe)\n    }\n    return final_output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [Int]) == [] as [String])"
    },
    {
        "id": 601,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    let t = 5\n    var tab = [String]()\n    for i in text {\n        if \"aeiouy\".contains(i.lowercased()) {\n            tab.append(String(repeating: i.uppercased(), count: t))\n        } else {\n            tab.append(String(repeating: i, count: t))\n        }\n    }\n    return tab.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"csharp\") == \"ccccc sssss hhhhh AAAAA rrrrr ppppp\")"
    },
    {
        "id": 602,
        "code": "\n/// \nfunc f(nums: [Int], target: Int) -> Int {\n    let cnt = nums.filter { $0 == target }.count\n    return cnt * 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1], target: 1) == 4)"
    },
    {
        "id": 603,
        "code": "func f(sentences: String) -> String {\n    let sentenceArray = sentences.split(separator: \".\")\n    if sentenceArray.allSatisfy({ $0.allSatisfy { $0.isNumber } }) {\n        return \"oscillating\"\n    } else {\n        return \"not oscillating\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(sentences: \"not numbers\") == \"not oscillating\")"
    },
    {
        "id": 604,
        "code": "\n/// \nfunc f(text: String, start: String) -> Bool {\n    return text.hasPrefix(start)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Hello world\", start: \"Hello\") == true)"
    },
    {
        "id": 605,
        "code": "\n/// \nfunc f(nums: [Int]) -> String {\n    var nums = nums\n    nums.removeAll()\n    return \"quack\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 5, 1, 7, 9, 3]) == \"quack\")"
    },
    {
        "id": 606,
        "code": "\n/// \nfunc f(value: String) -> String {\n    var ls = Array(value)\n    ls.append(contentsOf: \"NHIB\")\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(value: \"ruam\") == \"ruamNHIB\")"
    },
    {
        "id": 607,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    let endings = [\".\", \"!\", \"?\"]\n    \n    for ending in endings {\n        if text.hasSuffix(ending) {\n            return true\n        }\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \". C.\") == true)"
    },
    {
        "id": 608,
        "code": "\n/// \nfunc f(aDict: [AnyHashable : AnyHashable]) -> [AnyHashable : AnyHashable] {\n    return Dictionary(uniqueKeysWithValues: aDict.map { ($1, $0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(aDict: [1 : 1, 2 : 2, 3 : 3]) == [1 : 1, 2 : 2, 3 : 3])"
    },
    {
        "id": 609
    },
    {
        "id": 610,
        "code": "\n\nfunc f(keys: [Int], value: Int) -> [Int : Int] {\n    var d: [Int : Int] = [:]\n    for key in keys {\n        d[key] = value\n    }\n    var keys = d.keys\n    for (i, k) in keys.enumerated() {\n        if let val = d[k], d[i + 1] == val {\n            d[i + 1] = nil\n        }\n    }\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(keys: [1, 2, 1, 1], value: 3) == [:] as [Int : Int])"
    },
    {
        "id": 611,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var reversedNums = nums.reversed()\n    return Array(reversedNums)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-6, -2, 1, -3, 0, 1]) == [1, 0, -3, 1, -2, -6])"
    },
    {
        "id": 612,
        "code": "\n/// \nfunc f(d: [String : Int]) -> [String : Int] {\n    return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"a\" : 42, \"b\" : 1337, \"c\" : -1, \"d\" : 5]) == [\"a\" : 42, \"b\" : 1337, \"c\" : -1, \"d\" : 5])"
    },
    {
        "id": 613
    },
    {
        "id": 614,
        "code": "import Foundation\n\nfunc f(text: String, substr: String, occ: Int) -> Int {\n    var text = text\n    var n = 0\n    \n    while true {\n        if let range = text.range(of: substr, options: .backwards) {\n            let i = text.distance(from: text.startIndex, to: range.lowerBound)\n            if n == occ {\n                return i\n            } else {\n                n += 1\n                text = String(text[..<range.lowerBound])\n            }\n        } else {\n            break\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"zjegiymjc\", substr: \"j\", occ: 2) == -1)"
    },
    {
        "id": 615,
        "code": "\n/// \nfunc f(in_list: [Int], num: Int) -> Int {\nvar mutableList = in_list\nmutableList.append(num)\nreturn mutableList.firstIndex(of: mutableList.dropLast().max()!)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(in_list: [-1, 12, -6, -2], num: -1) == 1)"
    },
    {
        "id": 616
    },
    {
        "id": 617,
        "code": "\n/// \nfunc f(text: String) -> String {\n    if text.utf8.allSatisfy({ $0 < 128 }) {\n        return \"ascii\"\n    } else {\n        return \"non ascii\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"<<<<\") == \"ascii\")"
    },
    {
        "id": 618,
        "code": "\n/// \nfunc f(match: String, fill: String, n: Int) -> String {\n    return fill.prefix(n) + match\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(match: \"9\", fill: \"8\", n: 2) == \"89\")"
    },
    {
        "id": 619,
        "code": "\n/// \nfunc f(title: String) -> String {\n    return title.lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(title: \"   Rock   Paper   SCISSORS  \") == \"   rock   paper   scissors  \")"
    },
    {
        "id": 620,
        "code": "func f(x: String) -> String {\n    return x.reversed().map { String($0) }.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(x: \"lert dna ndqmxohi3\") == \"3 i h o x m q d n   a n d   t r e l\")"
    },
    {
        "id": 621
    },
    {
        "id": 622
    },
    {
        "id": 623,
        "code": "\n/// \nfunc f(text: String, rules: [String]) -> String {\n    var modifiedText = text\n    for rule in rules {\n        if rule == \"@\" {\n            modifiedText = String(modifiedText.reversed())\n        } else if rule == \"~\" {\n            modifiedText = modifiedText.uppercased()\n        } else if !modifiedText.isEmpty, modifiedText.last == Character(rule) {\n            modifiedText = String(modifiedText.dropLast())\n        }\n    }\n    return modifiedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"hi~!\", rules: [\"~\", \"`\", \"!\", \"&\"]) == \"HI~\")"
    },
    {
        "id": 624
    },
    {
        "id": 625,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var count = 0\n    for i in text {\n        if \".?!.,\".contains(i) {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"bwiajegrwjd??djoda,?\") == 4)"
    },
    {
        "id": 626,
        "code": "import Foundation\n\nfunc f(line: String, equalityMap: [(String, String)]) -> String {\n    var rs = [Character: Character]()\n    for (k, v) in equalityMap {\n        if let key = k.first, let value = v.first {\n            rs[key] = value\n        }\n    }\n    \n    var translatedLine = \"\"\n    for char in line {\n        if let translatedChar = rs[char] {\n            translatedLine.append(translatedChar)\n        } else {\n            translatedLine.append(char)\n        }\n    }\n    \n    return translatedLine\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(line: \"abab\", equalityMap: [(\"a\", \"b\"), (\"b\", \"a\")]) == \"baba\")"
    },
    {
        "id": 627,
        "code": "\n/// \nfunc f(parts: [(String, Int)]) -> [Int] {\n    return Array(Dictionary(parts, uniquingKeysWith: { $1 }).values)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(parts: [(\"u\", 1), (\"s\", 7), (\"u\", -5)]) == [-5, 7])"
    },
    {
        "id": 628,
        "code": "\n/// \nfunc f(nums: [Int], delete: Int) -> [Int] {\n    var updatedNums = nums\n    if let index = updatedNums.firstIndex(of: delete) {\n        updatedNums.remove(at: index)\n    }\n    return updatedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [4, 5, 3, 6, 1], delete: 5) == [4, 3, 6, 1])"
    },
    {
        "id": 629,
        "code": "\n\nimport Foundation\n\nfunc f(text: String, dng: String) -> String {\n    if !text.contains(dng) {\n        return text\n    }\n    if text.suffix(dng.count) == dng {\n        return String(text.dropLast(dng.count))\n    }\n    return f(text: String(text.dropLast()), dng: dng)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"catNG\", dng: \"NG\") == \"cat\")"
    },
    {
        "id": 630,
        "code": "\n/// \nfunc f(original: [Int : Int], string: [Int : Int]) -> [Int : Int] {\n    var temp = original\n    for (a, b) in string {\n        temp[b] = a\n    }\n    return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(original: [1 : -9, 0 : -7], string: [1 : 2, 0 : 3]) == [1 : -9, 0 : -7, 2 : 1, 3 : 0])"
    },
    {
        "id": 631
    },
    {
        "id": 632,
        "code": "\n/// \nfunc f(lst: [Int]) -> [Int] {\n    var sortedList = lst\n    for i in (1..<sortedList.count).reversed() {\n        for j in 0..<i {\n            if sortedList[j] > sortedList[j + 1] {\n                let temp = sortedList[j]\n                sortedList[j] = sortedList[j + 1]\n                sortedList[j + 1] = temp\n            }\n        }\n    }\n    return sortedList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [63, 0, 1, 5, 9, 87, 0, 7, 25, 4]) == [0, 0, 1, 4, 5, 7, 9, 25, 63, 87])"
    },
    {
        "id": 633,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> Int {\n    var reversedArray = array.reversed()\n    if let foundIndex = reversedArray.firstIndex(of: elem) {\n        return reversedArray.distance(from: reversedArray.startIndex, to: foundIndex)\n    } else {\n        return -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [5, -3, 3, 2], elem: 2) == 0)"
    },
    {
        "id": 634,
        "code": "\n/// \nfunc f(input_string: String) -> String {\n    var table = [\"a\": \"i\", \"i\": \"o\", \"o\": \"u\", \"e\": \"a\"]\n    var inputString = input_string\n    \n    while inputString.contains(\"a\") || inputString.contains(\"A\") {\n        inputString = inputString.map { table[String($0).lowercased()] ?? String($0) }.joined()\n    }\n    \n    return inputString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(input_string: \"biec\") == \"biec\")"
    },
    {
        "id": 635,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    let valid_chars: [Character] = [\"-\", \"_\", \"+\", \".\", \"/\", \" \"]\n    let uppercasedText = text.uppercased()\n    \n    for char in uppercasedText {\n        if !char.isLetter && !valid_chars.contains(char) {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"9.twCpTf.H7 HPeaQ^ C7I6U,C:YtW\") == false)"
    },
    {
        "id": 636,
        "code": "\n/// \nfunc f(d: [Int : String]) -> [Int : String] {\n    var r: [Int: String] = [:]\n    var mutableDictionary = d\n    \n    while !mutableDictionary.isEmpty {\n        r.merge(mutableDictionary) { _, new in new }\n        mutableDictionary.removeValue(forKey: mutableDictionary.keys.max()!)\n    }\n    \n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [3 : \"A3\", 1 : \"A1\", 2 : \"A2\"]) == [3 : \"A3\", 1 : \"A1\", 2 : \"A2\"])"
    },
    {
        "id": 637,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let textArray = text.split(separator: \" \")\n    for t in textArray {\n        if !t.allSatisfy({ $0.isNumber }) {\n            return \"no\"\n        }\n    }\n    return \"yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"03625163633 d\") == \"no\")"
    },
    {
        "id": 638,
        "code": "\n/// \nfunc f(s: String, suffix: String) -> String {\n    if suffix.isEmpty {\n        return s\n    }\n    \n    var result = s\n    \n    while result.hasSuffix(suffix) {\n        result = String(result.dropLast(suffix.count))\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"ababa\", suffix: \"ab\") == \"ababa\")"
    },
    {
        "id": 639,
        "code": "\n/// \nfunc f(perc: String, full: String) -> String {\n    var reply = \"\"\n    var i = 0\n    while i < full.count && i < perc.count && perc[perc.index(perc.startIndex, offsetBy: i)] == full[full.index(full.startIndex, offsetBy: i)] {\n        if perc[perc.index(perc.startIndex, offsetBy: i)] == full[full.index(full.startIndex, offsetBy: i)] {\n            reply += \"yes \"\n        } else {\n            reply += \"no \"\n        }\n        i += 1\n    }\n    return reply\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(perc: \"xabxfiwoexahxaxbxs\", full: \"xbabcabccb\") == \"yes \")"
    },
    {
        "id": 640,
        "code": "func f(text: String) -> Int {\n    var a = 0\n    let textArray = Array(text)\n    \n    if textArray.count > 1 && textArray[1...].contains(textArray[0]) {\n        a += 1\n    }\n    \n    for i in 0..<textArray.count - 1 {\n        if textArray[(i + 1)...].contains(textArray[i]) {\n            a += 1\n        }\n    }\n    \n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"3eeeeeeoopppppppw14film3oee3\") == 18)"
    },
    {
        "id": 641,
        "code": "import Foundation\n\nfunc f(number: String) -> Bool {\n    return number.rangeOfCharacter(from: CharacterSet.decimalDigits.inverted) == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(number: \"dummy33;d\") == false)"
    },
    {
        "id": 642,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var i = 0\n    while i < text.count && text[text.index(text.startIndex, offsetBy: i)].isWhitespace {\n        i += 1\n    }\n    if i == text.count {\n        return \"space\"\n    }\n    return \"no\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"     \") == \"space\")"
    },
    {
        "id": 643,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    var updatedText = text\n    if updatedText.hasSuffix(suffix) {\n        let lastIndex = updatedText.index(updatedText.endIndex, offsetBy: -1)\n        let lastCharacter = updatedText[lastIndex]\n        updatedText.removeLast()\n        updatedText.append(lastCharacter.uppercased() == String(lastCharacter) ? lastCharacter.lowercased() : lastCharacter.uppercased())\n    }\n    return updatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"damdrodm\", suffix: \"m\") == \"damdrodM\")"
    },
    {
        "id": 644,
        "code": "func f(nums: [Int], pos: Int) -> [Int] {\n    var numsCopy = nums\n    var s = numsCopy.startIndex..<numsCopy.endIndex\n    if pos % 2 == 1 {\n        s = s.lowerBound..<numsCopy.index(before: numsCopy.endIndex)\n    }\n    numsCopy[s].reverse()\n    return numsCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [6, 1], pos: 3) == [6, 1])"
    },
    {
        "id": 645,
        "code": "\n/// \nfunc f(nums: [Int], target: Int) -> Int {\n    if nums.filter({ $0 == 0 }).count > 0 {\n        return 0\n    } else if nums.filter({ $0 == target }).count < 3 {\n        return 1\n    } else {\n        return nums.firstIndex(of: target) ?? 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1, 1, 2], target: 3) == 1)"
    },
    {
        "id": 646,
        "code": "\n/// \nfunc f(text: String, count: Int) -> String {\n    var updatedText = text\n    for _ in 0..<count {\n        updatedText = String(updatedText.reversed())\n    }\n    return updatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"aBc, ,SzY\", count: 2) == \"aBc, ,SzY\")"
    },
    {
        "id": 647,
        "code": "\n/// \nfunc f(text: String, chunks: Int) -> [String] {\n    return text.split(separator: \"\\n\").map(String.init)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"/alcm@ an)t//eprw)/e!/d\\nujv\", chunks: 0) == [\"/alcm@ an)t//eprw)/e!/d\", \"ujv\"])"
    },
    {
        "id": 648,
        "code": "\nextension String: Error {}\n        \n/// \nfunc f(list1: [Int], list2: [Int]) -> Result<Int, String> {\n    var l = list1\n    while !l.isEmpty {\n        if list2.contains(l.last!) {\n            l.removeLast()\n        } else {\n            return .success(l.last!)\n        }\n    }\n    return .failure(\"missing\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(list1: [0, 4, 5, 6], list2: [13, 23, -5, 0]) == .success(6))"
    },
    {
        "id": 649,
        "code": "import Foundation\n\nfunc f(text: String, tabsize: Int) -> String {\n    return text.split(separator: \"\\n\").map { $0.replacingOccurrences(of: \"\\t\", with: String(repeating: \" \", count: tabsize)) }.joined(separator: \"\\n\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"\\tf9\\n\\tldf9\\n\\tadf9!\\n\\tf9?\", tabsize: 1) == \" f9\\n ldf9\\n adf9!\\n f9?\")"
    },
    {
        "id": 650,
        "code": "\n/// \nfunc f(string: String, substring: String) -> String {\n    var string = string\n    while string.hasPrefix(substring) {\n        string = String(string.dropFirst(substring.count))\n    }\n    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"\", substring: \"A\") == \"\")"
    },
    {
        "id": 651,
        "code": "\n\n/// \nfunc f(text: String, letter: String) -> String {\n    let letter = letter.uppercased()\n    let text = String(text.map { char in letter == String(char).lowercased() ? Character(letter) : char })\n    return text.prefix(1).uppercased() + text.dropFirst()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"E wrestled evil until upperfeat\", letter: \"e\") == \"E wrestled evil until upperfeat\")"
    },
    {
        "id": 652,
        "code": "\n/// \nfunc f(string: String) -> String {\n    if string.isEmpty || !string.prefix(1).allSatisfy({ $0.isNumber }) {\n        return \"INVALID\"\n    }\n    \n    var cur = 0\n    for char in string {\n        if let number = Int(String(char)) {\n            cur = cur * 10 + number\n        }\n    }\n    \n    return String(cur)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"3\") == \"3\")"
    },
    {
        "id": 653
    },
    {
        "id": 654,
        "code": "\n/// \nfunc f(s: String, from_c: String, to_c: String) -> String {\n    var table = [Character: Character]()\n    for (fromChar, toChar) in zip(from_c, to_c) {\n        table[fromChar] = toChar\n    }\n    \n    var result = \"\"\n    for char in s {\n        if let mappedChar = table[char] {\n            result.append(mappedChar)\n        } else {\n            result.append(char)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"aphid\", from_c: \"i\", to_c: \"?\") == \"aph?d\")"
    },
    {
        "id": 655,
        "code": "\nimport Foundation\n\nfunc f(s: String) -> String {\n    return s.replacingOccurrences(of: \"a\", with: \"\")\n           .replacingOccurrences(of: \"r\", with: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"rpaar\") == \"p\")"
    },
    {
        "id": 656,
        "code": "\n/// \nfunc f(letters: [String]) -> String {\n    var a: [String] = []\n    for i in 0..<letters.count {\n        if a.contains(letters[i]) {\n            return \"no\"\n        }\n        a.append(letters[i])\n    }\n    return \"yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(letters: [\"b\", \"i\", \"r\", \"o\", \"s\", \"j\", \"v\", \"p\"]) == \"yes\")"
    },
    {
        "id": 657,
        "code": "\n\nfunc f(text: String) -> String {\n    let punctuations = \"!.?,:;\"\n    \n    for punctuation in punctuations {\n        if text.filter { $0 == punctuation }.count > 1 || text.last == punctuation {\n            return \"no\"\n        }\n    }\n    \n    return text.prefix(1).uppercased() + text.dropFirst().lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"djhasghasgdha\") == \"Djhasghasgdha\")"
    },
    {
        "id": 658,
        "code": "\n\nfunc f(d: [Int : String], get_ary: [Int]) -> [String?] {\n    var result: [String?] = []\n    for key in get_ary {\n        result.append(d[key])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [3 : \"swims like a bull\"], get_ary: [3, 2, 5]) == [\"swims like a bull\", nil, nil])"
    },
    {
        "id": 659,
        "code": "\n/// \nfunc f(bots: [String]) -> Int {\n    var clean: [String] = []\n    for username in bots {\n        if username != username.uppercased() {\n            clean.append(String(username.prefix(2) + username.suffix(3)))\n        }\n    }\n    return clean.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(bots: [\"yR?TAJhIW?n\", \"o11BgEFDfoe\", \"KnHdn2vdEd\", \"wvwruuqfhXbGis\"]) == 4)"
    },
    {
        "id": 660,
        "code": "\n/// \nfunc f(num: Int) -> Int {\n    var initial = [1]\n    var total = initial\n    for _ in 0..<num {\n        total = [1] + zip(total, total.dropFirst()).map { $0 + $1 }\n        initial.append(total.last!)\n    }\n    return initial.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: 3) == 4)"
    },
    {
        "id": 661,
        "code": "import Foundation\n\nfunc f(letters: String, maxsplit: Int) -> String {\n    let splitLetters = letters.split(separator: \" \")\n    let result = splitLetters.suffix(maxsplit).joined()\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(letters: \"elrts,SS ee\", maxsplit: 6) == \"elrts,SSee\")"
    },
    {
        "id": 662,
        "code": "\n/// \nfunc f(values: [String]) -> [String] {\n    var names = [\"Pete\", \"Linda\", \"Angela\"]\n    names.append(contentsOf: values)\n    names.sort()\n    return names\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(values: [\"Dan\", \"Joe\", \"Dusty\"]) == [\"Angela\", \"Dan\", \"Dusty\", \"Joe\", \"Linda\", \"Pete\"])"
    },
    {
        "id": 663
    },
    {
        "id": 664,
        "code": "\n\n/// \nfunc f(tags: [String : String]) -> String {\n    var resp = \"\"\n    for key in tags.keys {\n        resp += key + \" \"\n    }\n    return resp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(tags: [\"3\" : \"3\", \"4\" : \"5\"]) == \"3 4 \")"
    },
    {
        "id": 665,
        "code": "\n/// \nfunc f(chars: String) -> String {\n    var s = \"\"\n    for ch in chars {\n        if chars.filter({$0 == ch}).count % 2 == 0 {\n            s += ch.uppercased()\n        } else {\n            s += String(ch)\n        }\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(chars: \"acbced\") == \"aCbCed\")"
    },
    {
        "id": 666,
        "code": "\n/// \nfunc f(d1: [Int : [Int]], d2: [Int : [Int]]) -> Int {\n    var mmax = 0\n    for (k1, v1) in d1 {\n        let p = v1.count + (d2[k1]?.count ?? 0)\n        if p > mmax {\n            mmax = p\n        }\n    }\n    return mmax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d1: [0 : [] as [Int], 1 : [] as [Int]], d2: [0 : [0, 0, 0, 0], 2 : [2, 2, 2]]) == 4)"
    },
    {
        "id": 667,
        "code": "\n/// \nfunc f(text: String) -> [String] {\n    var new_text: [String] = []\n    for i in 0..<(text.count / 3) {\n        let startIndex = text.index(text.startIndex, offsetBy: i * 3)\n        let endIndex = text.index(text.startIndex, offsetBy: i * 3 + 3)\n        let substr = String(text[startIndex..<endIndex])\n        new_text.append(\"< \\(substr) level=\\(i) >\")\n    }\n    \n    let last_item = String(text.suffix(text.count - (text.count / 3) * 3))\n    new_text.append(\"< \\(last_item) level=\\(text.count / 3) >\")\n    \n    return new_text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"C7\") == [\"< C7 level=0 >\"])"
    },
    {
        "id": 668,
        "code": "\n/// \nfunc f(text: String) -> String {\n    return String(text.last!) + String(text.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"hellomyfriendear\") == \"rhellomyfriendea\")"
    },
    {
        "id": 669,
        "code": "\n\n/// \nfunc f(t: String) -> String {\n    let components = t.split(separator: \"-\").map { String($0) }\n    let a = components.count > 0 ? components[0] : \"\"\n    let b = components.count > 2 ? components[2] : \"\"\n    \n    if a.count == b.count {\n        return \"imbalanced\"\n    }\n    \n    return a + b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(t: \"fubarbaz\") == \"fubarbaz\")"
    },
    {
        "id": 670,
        "code": "func f(a: [AnyHashable], b: [Int]) -> [Int] {\n    var d = Dictionary(uniqueKeysWithValues: zip(a, b))\n    var sortedA = a\n    sortedA.sort { d[$0]! > d[$1]! }\n    return sortedA.compactMap { d.removeValue(forKey: $0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(a: [\"12\", \"ab\"], b: [2, 2]) == [2, 2])"
    },
    {
        "id": 671,
        "code": "\n/// \nfunc f(text: String, char1: String, char2: String) -> String {\n    var t1a: [Character] = []\n    var t2a: [Character] = []\n    \n    for i in 0..<char1.count {\n        t1a.append(char1[char1.index(char1.startIndex, offsetBy: i)])\n        t2a.append(char2[char2.index(char2.startIndex, offsetBy: i)])\n    }\n    \n    var map = [Character: Character]()\n    for (key, value) in zip(t1a, t2a) {\n        map[key] = value\n    }\n    \n    var translatedText = \"\"\n    for char in text {\n        if let translatedChar = map[char] {\n            translatedText.append(translatedChar)\n        } else {\n            translatedText.append(char)\n        }\n    }\n    \n    return translatedText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ewriyat emf rwto segya\", char1: \"tey\", char2: \"dgo\") == \"gwrioad gmf rwdo sggoa\")"
    },
    {
        "id": 672,
        "code": "\n/// \nfunc f(text: String, position: Int, value: String) -> String {\n    let length = text.count\n    let lengthPlusTwo = length + 2\n    var index = (position % lengthPlusTwo) - 1\n    if index >= length || index < 0 {\n        return text\n    }\n    var textArray = Array(text)\n    textArray[index] = Character(value)\n    return String(textArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"1zd\", position: 0, value: \"m\") == \"1zd\")"
    },
    {
        "id": 673,
        "code": "\n/// \nfunc f(string: String) -> String {\n    if string.uppercased() == string {\n        return string.lowercased()\n    } else if string.lowercased() == string {\n        return string.uppercased()\n    }\n    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"cA\") == \"cA\")"
    },
    {
        "id": 674,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var ls = Array(text)\n    var x = ls.count - 1\n    while x >= 0 {\n        if ls.count <= 1 { break }\n        if !(\"zyxwvutsrqponmlkjihgfedcba\".contains(ls[x])) {\n            ls.remove(at: x)\n        }\n        x -= 1\n    }\n    return String(ls)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"qq\") == \"qq\")"
    },
    {
        "id": 675,
        "code": "\n/// \nfunc f(nums: [Int], sort_count: Int) -> [Int] {\n    var sortedNums = nums.sorted()\n    return Array(sortedNums.prefix(sort_count))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 2, 2, 3, 4, 5], sort_count: 1) == [1])"
    },
    {
        "id": 676,
        "code": "\nimport Foundation\n\nfunc f(text: String, tab_size: Int) -> String {\n    let tabReplacement = String(repeating: \" \", count: tab_size)\n    return text.replacingOccurrences(of: \"    \", with: tabReplacement)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a\", tab_size: 100) == \"a\")"
    },
    {
        "id": 677,
        "code": "\n/// \nfunc f(text: String, length: Int) -> String {\n    var length = length < 0 ? -length : length\n    var output = \"\"\n    for idx in 0..<length {\n        let charIndex = text.index(text.startIndex, offsetBy: idx % text.count)\n        if text[charIndex] != \" \" {\n            output.append(text[charIndex])\n        } else {\n            break\n        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"I got 1 and 0.\", length: 5) == \"I\")"
    },
    {
        "id": 678,
        "code": "func f(text: String) -> [String: Int] {\n    var freq = [String: Int]()\n    for c in text.lowercased() {\n        let charString = String(c)\n        if let count = freq[charString] {\n            freq[charString] = count + 1\n        } else {\n            freq[charString] = 1\n        }\n    }\n    return freq\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"HI\") == [\"h\" : 1, \"i\" : 1])"
    },
    {
        "id": 679,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    if text.isEmpty {\n        return false\n    }\n    let firstChar = text.first!\n    if firstChar.isNumber {\n        return false\n    }\n    for lastChar in text {\n        if (lastChar != \"_\") && !lastChar.isLetter && !lastChar.isNumber && lastChar != \"_\" {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"meet\") == true)"
    },
    {
        "id": 680,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    var letters = \"\"\n    for i in 0..<text.count {\n        if text[text.index(text.startIndex, offsetBy: i)].isLetter || text[text.index(text.startIndex, offsetBy: i)].isNumber {\n            letters += String(text[text.index(text.startIndex, offsetBy: i)] )\n        }\n    }\n    return letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"we@32r71g72ug94=(823658*!@324\") == \"we32r71g72ug94823658324\")"
    },
    {
        "id": 681,
        "code": "\n/// \nfunc f(array: [Int], ind: Int, elem: Int) -> [Int] {\n    var updatedArray = array\n    updatedArray.insert(elem, at: ind < 0 ? -5 : ind > array.count ? array.count : ind + 1)\n    return updatedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 5, 8, 2, 0, 3], ind: 2, elem: 7) == [1, 5, 8, 7, 2, 0, 3])"
    },
    {
        "id": 682,
        "code": "\n/// \nfunc f(text: String, length: Int, index: Int) -> String {\n    let ls = text.split(separator: \" \", maxSplits: index).map { String($0) }\n    let result = ls.map { String($0.prefix(length)) }.joined(separator: \"_\")\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"hypernimovichyp\", length: 2, index: 2) == \"hy\")"
    },
    {
        "id": 683,
        "code": "\n/// \nfunc f(dict1: [String : Int], dict2: [String : Int]) -> [String : Int] {\n    var result = dict1\n    for (key, value) in dict2 {\n        result[key] = value\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dict1: [\"disface\" : 9, \"cam\" : 7], dict2: [\"mforce\" : 5]) == [\"disface\" : 9, \"cam\" : 7, \"mforce\" : 5])"
    },
    {
        "id": 684,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let trans = [\"\\\"\": \"9\", \"'\": \"8\", \">\": \"3\", \"<\": \"3\"]\n    return text.reduce(\"\") { $0 + (trans[String($1)] ?? String($1)) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Transform quotations\\\"\\nnot into numbers.\") == \"Transform quotations9\\nnot into numbers.\")"
    },
    {
        "id": 685,
        "code": "\n/// \nfunc f(array: [Int], elem: Int) -> Int {\n    return array.filter({ $0 == elem }).count + elem\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [1, 1, 1], elem: -2) == -2)"
    },
    {
        "id": 686,
        "code": "\n/// \nfunc f(d: [String : Int], l: [String]) -> [String : Int] {\n    var new_d: [String: Int] = [:]\n\n    for k in l {\n        if let value = d[k] {\n            new_d[k] = value\n        }\n    }\n\n    return new_d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"lorem ipsum\" : 12, \"dolor\" : 23], l: [\"lorem ipsum\", \"dolor\"]) == [\"lorem ipsum\" : 12, \"dolor\" : 23])"
    },
    {
        "id": 687
    },
    {
        "id": 688,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var l: [Int] = []\n    \n    for i in nums {\n        if !l.contains(i) {\n            l.append(i)\n        }\n    }\n    \n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [3, 1, 9, 0, 2, 0, 8]) == [3, 1, 9, 0, 2, 8])"
    },
    {
        "id": 689,
        "code": "\n/// \nfunc f(arr: [Int]) -> [Int] {\n    var sub = arr\n    for i in stride(from: 0, to: sub.count, by: 2) {\n        sub[i] *= 5\n    }\n    return sub\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(arr: [-3, -6, 2, 7]) == [-15, -6, 10, 7])"
    },
    {
        "id": 690,
        "code": "\n/// \nfunc f(n: String) -> String {\n    if n.contains(\".\") {\n        return String(Int(Double(n)! + 2.5))\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: \"800\") == \"800\")"
    },
    {
        "id": 691,
        "code": "import Foundation\n\nfunc f(text: String, suffix: String) -> String {\n    if !suffix.isEmpty, let lastChar = suffix.last, text.contains(lastChar) {\n        let trimmedText = text.hasSuffix(String(lastChar)) ? String(text.dropLast()) : text\n        return f(text: trimmedText, suffix: String(suffix.dropLast()))\n    } else {\n        return text\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"rpyttc\", suffix: \"cyt\") == \"rpytt\")"
    },
    {
        "id": 692,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var a: [Int] = []\n    var reversedArray = array.reversed()\n    for element in reversedArray {\n        if element != 0 {\n            a.append(element)\n        }\n    }\n    return a.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 693,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let n = text.firstIndex(of: \"8\") ?? text.endIndex\n    let count = text.distance(from: text.startIndex, to: n)\n    return String(repeating: \"x0\", count: count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"sa832d83r xd 8g 26a81xdf\") == \"x0x0\")"
    },
    {
        "id": 694,
        "code": "\n\nfunc f(d: [String : Int]) -> (String, [String : Int]) {\n    let keys = Array(d.keys)\n    let i = keys.count - 1\n    let key = keys[i]\n    var newDict = d\n    newDict[key] = nil\n    return (key, newDict)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [\"e\" : 1, \"d\" : 2, \"c\" : 3]) == (\"c\", [\"e\" : 1, \"d\" : 2]))"
    },
    {
        "id": 695,
        "code": "\n\n///\nfunc f(d: [String : [AnyHashable]]) -> [String : [AnyHashable]] {\n    var result: [String : [AnyHashable]] = [:]\n    for (ki, li) in d {\n        result.updateValue([], forKey: ki)\n        for (kj, dj) in li.enumerated() {\n            guard var temp = result[ki] else {\n                continue\n            }\n            temp.append(dj)\n            result[ki] = temp\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(d: [:] as [String : [AnyHashable]]) == [:] as [String : [AnyHashable]])"
    },
    {
        "id": 696,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var s = 0\n    for i in 1..<text.count {\n        s += text.prefix(i).count\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wdj\") == 3)"
    },
    {
        "id": 697
    },
    {
        "id": 698,
        "code": "\n/// \nfunc f(text: String) -> String {\n    return text.filter { $0 != \")\" }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"(((((((((((d))))))))).))))(((((\") == \"(((((((((((d.(((((\")"
    },
    {
        "id": 699,
        "code": "\n\nfunc f(text: String, elem: String) -> [String] {\n    var mutableText = text\n    var mutableElem = elem\n    \n    if elem != \"\" {\n        while mutableText.hasPrefix(elem) {\n            mutableText = String(mutableText.dropFirst(elem.count))\n        }\n        while mutableElem.hasPrefix(text) {\n            mutableElem = String(mutableElem.dropFirst(text.count))\n        }\n    }\n    return [mutableElem, mutableText]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"some\", elem: \"1\") == [\"1\", \"some\"])"
    },
    {
        "id": 700
    },
    {
        "id": 701,
        "code": "\n\n/// \nfunc f(stg: String, tabs: [String]) -> String {\n    var newStg = stg\n    for tab in tabs {\n        while newStg.hasSuffix(tab) {\n            newStg.removeLast()\n        }\n    }\n    return newStg\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(stg: \"31849 let it!31849 pass!\", tabs: [\"3\", \"1\", \"8\", \" \", \"1\", \"9\", \"2\", \"d\"]) == \"31849 let it!31849 pass!\")"
    },
    {
        "id": 702,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var nums = nums\n    let count = nums.count\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        nums.insert(nums.removeFirst(), at: i)\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [0, -5, -4]) == [-4, -5, 0])"
    },
    {
        "id": 703
    },
    {
        "id": 704,
        "code": "func f(s: String, n: Int, c: String) -> String {\n    var width = c.count * n\n    var newString = s\n    while newString.count < width {\n        newString = c + newString\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \".\", n: 0, c: \"99\") == \".\")"
    },
    {
        "id": 705,
        "code": "\n/// \nfunc f(cities: [String], name: String) -> [String] {\n    if name.isEmpty {\n        return cities\n    }\n    if !name.isEmpty && name != \"cities\" {\n        return []\n    }\n    return cities.map { name + $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(cities: [\"Sydney\", \"Hong Kong\", \"Melbourne\", \"Sao Paolo\", \"Istanbul\", \"Boston\"], name: \"Somewhere \") == [] as [String])"
    },
    {
        "id": 706,
        "code": "\n/// \nfunc f(r: String, w: String) -> [String] {\n    var a: [String] = []\n    if r.first == w.first && w.last == r.last {\n        a.append(r)\n        a.append(w)\n    } else {\n        a.append(w)\n        a.append(r)\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(r: \"ab\", w: \"xy\") == [\"xy\", \"ab\"])"
    },
    {
        "id": 707,
        "code": "\n/// \nfunc f(text: String, position: Int) -> String {\n    let length = text.count\n    var index = position % (length + 1)\n    if position < 0 || index < 0 {\n        index = -1\n    }\n    var new_text = Array(text)\n    new_text.remove(at: index)\n    return String(new_text)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"undbs l\", position: 1) == \"udbs l\")"
    },
    {
        "id": 708,
        "code": "\n/// \nfunc f(string: String) -> String {\n    var l = Array(string)\n    for i in stride(from: l.count - 1, through: 0, by: -1) {\n        if l[i] != \" \" {\n            break\n        }\n        l.remove(at: i)\n    }\n    return String(l)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(string: \"    jcmfxv     \") == \"    jcmfxv\")"
    },
    {
        "id": 709,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let my_list = text.split(separator: \" \")\n    let sortedList = my_list.sorted(by: >)\n    return sortedList.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a loved\") == \"loved a\")"
    },
    {
        "id": 710,
        "code": "\n/// \nfunc f(playlist: [String : [String]], liker_name: String, song_index: String) -> [String : [String]] {\n    var updatedPlaylist = playlist\n    updatedPlaylist[liker_name, default: []].append(song_index)\n    return updatedPlaylist\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(playlist: [\"aki\" : [\"1\", \"5\"]], liker_name: \"aki\", song_index: \"2\") == [\"aki\" : [\"1\", \"5\", \"2\"]])"
    },
    {
        "id": 711,
        "code": "\nimport Foundation\n\nfunc f(text: String) -> String {\n    return text.replacingOccurrences(of: \"\\n\", with: \"\\t\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"apples\\n\\t\\npears\\n\\t\\nbananas\") == \"apples\\t\\t\\tpears\\t\\t\\tbananas\")"
    },
    {
        "id": 712,
        "code": "\n\n/// \nfunc f(text: String) -> [[String]] {\n    var created: [[String]] = []\n    for line in text.split(separator: \"\\n\") {\n        if line == \"\" {\n            break\n        }\n        let reversedLine = Array(line.reversed())\n        // Assuming flush is the index of the character to keep from the reversed line\n        var flush = 0\n        if flush < reversedLine.count {\n            created.append([String(reversedLine[flush])])\n        }\n    }\n    return Array(created.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"A(hiccup)A\") == [[\"A\"]])"
    },
    {
        "id": 713,
        "code": "\nimport Foundation\n\nfunc f(text: String, char: String) -> Bool {\n    if text.contains(char) {\n        let textArray = text.split(separator: Character(char)).compactMap{ String($0).trimmingCharacters(in: .whitespaces) }\n        if textArray.count > 1 {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"only one line\", char: \" \") == true)"
    },
    {
        "id": 714
    },
    {
        "id": 715,
        "code": "\n/// \nfunc f(text: String, char: String) -> Bool {\n    return text.filter { String($0) == char }.count % 2 != 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"abababac\", char: \"a\") == false)"
    },
    {
        "id": 716,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var numsCopy = nums\n    let count = numsCopy.count\n    while numsCopy.count > count / 2 {\n        numsCopy.removeAll()\n    }\n    return numsCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 1, 2, 3, 1, 6, 3, 8]) == [] as [Int])"
    },
    {
        "id": 717,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var k = 0\n    var l = text.count - 1\n    let chars = Array(text)\n\n    while !chars[l].isLetter {\n        l -= 1\n    }\n\n    while !chars[k].isLetter {\n        k += 1\n    }\n\n    if k != 0 || l != text.count - 1 {\n        return String(chars[k...l])\n    } else {\n        return String(chars[0])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"timetable, 2mil\") == \"t\")"
    },
    {
        "id": 718,
        "code": "\n\n/// \nfunc f(text: String) -> String {\n    var t = Array(text)\n    var count = text.count\n    for i in text {\n        if let index = t.firstIndex(of: i) {\n            t.remove(at: index)\n            count -= 1\n        }\n    }\n    return String(count) + text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ThisIsSoAtrocious\") == \"0ThisIsSoAtrocious\")"
    },
    {
        "id": 719,
        "code": "\n\nfunc f(code: String) -> String {\n    var lines = code.split(separator: \"]\")\n    var result = [String]()\n    var level = 0\n    for line in lines {\n        if let firstChar = line.first {\n            let spaces = String(repeating: \"  \", count: level)\n            let modifiedLine = String(firstChar) + \" \" + spaces + String(line.dropFirst())\n            result.append(modifiedLine)\n            level += line.filter { \"{\" == String($0) }.count - line.filter { \"}\" == String($0) }.count\n        }\n    }\n    return result.joined(separator: \"\\n\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(code: \"if (x) {y = 1;} else {z = 1;}\") == \"i f (x) {y = 1;} else {z = 1;}\")"
    },
    {
        "id": 720,
        "code": "\n\nfunc f(items: [String], item: String) -> Int {\n    var mutableItems = items\n    while let lastItem = mutableItems.last, lastItem == item {\n        mutableItems.removeLast()\n    }\n    mutableItems.append(item)\n    return mutableItems.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(items: [\"bfreratrrbdbzagbretaredtroefcoiqrrneaosf\"], item: \"n\") == 2)"
    },
    {
        "id": 721,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var sortedNums = nums.sorted()\n    return sortedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-6, -5, -7, -8, 2]) == [-8, -7, -6, -5, 2])"
    },
    {
        "id": 722,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var out = \"\"\n    for i in 0..<text.count {\n        let char = text[text.index(text.startIndex, offsetBy: i)]\n        if char.isUppercase {\n            out.append(char.lowercased())\n        } else {\n            out.append(char.uppercased())\n        }\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \",wPzPppdl/\") == \",WpZpPPDL/\")"
    },
    {
        "id": 723
    },
    {
        "id": 724,
        "code": "\nimport Foundation\n\nfunc f(text: String, function: String) -> [Int] {\n    var cites = [text.components(separatedBy: function).joined().count]\n    for character in text {\n        if String(character) == function {\n            cites.append(text.components(separatedBy: function).joined().count)\n        }\n    }\n    return cites\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"010100\", function: \"010\") == [3])"
    },
    {
        "id": 725,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var result_list = [\"3\", \"3\", \"3\", \"3\"]\n    if !result_list.isEmpty {\n        result_list.removeAll()\n    }\n    return text.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"mrq7y\") == 5)"
    },
    {
        "id": 726,
        "code": "\n\n/// \nfunc f(text: String) -> (Int, Int) {\n    var ws = 0\n    for s in text {\n        if s.isWhitespace {\n            ws += 1\n        }\n    }\n    return (ws, text.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"jcle oq wsnibktxpiozyxmopqkfnrfjds\") == (2, 34))"
    },
    {
        "id": 727,
        "code": "\n/// \nfunc f(numbers: [String], prefix: String) -> [String] {\n    return numbers.map { n in\n        if n.count > prefix.count && n.hasPrefix(prefix) {\n            return String(n.dropFirst(prefix.count))\n        } else {\n            return n\n        }\n    }.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(numbers: [\"ix\", \"dxh\", \"snegi\", \"wiubvu\"], prefix: \"\") == [\"dxh\", \"ix\", \"snegi\", \"wiubvu\"])"
    },
    {
        "id": 728,
        "code": "func f(text: String) -> String {\n    var result: [Character] = []\n    \n    for (i, ch) in text.enumerated() {\n        if ch == ch.lowercased().first {\n            continue\n        }\n        if text.count - 1 - i < text.distance(from: text.startIndex, to: text.lastIndex(of: Character(ch.lowercased()))!) {\n            result.append(ch)\n        }\n    }\n    \n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"ru\") == \"\")"
    },
    {
        "id": 729
    },
    {
        "id": 730,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    var m = 0\n    var cnt = 0\n    for i in text.split(separator: \" \") {\n        if i.count > m {\n            cnt += 1\n            m = i.count\n        }\n    }\n    return cnt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wys silak v5 e4fi rotbi fwj 78 wigf t8s lcl\") == 2)"
    },
    {
        "id": 731,
        "code": "\nimport Foundation\n\nfunc f(text: String, use: String) -> String {\n    return text.replacingOccurrences(of: use, with: \"\", options: .regularExpression, range: nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"Chris requires a ride to the airport on Friday.\", use: \"a\") == \"Chris requires  ride to the irport on Fridy.\")"
    },
    {
        "id": 732,
        "code": "\n/// \nfunc f(char_freq: [String : Int]) -> [String : Int] {\n    var result: [String: Int] = [:]\n    for (k, v) in char_freq {\n        result[k] = v / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(char_freq: [\"u\" : 20, \"v\" : 5, \"b\" : 7, \"w\" : 3, \"x\" : 3]) == [\"u\" : 10, \"v\" : 2, \"b\" : 3, \"w\" : 1, \"x\" : 1])"
    },
    {
        "id": 733,
        "code": "\n/// \nfunc f(text: String) -> String {\n    let length = text.count / 2\n    let leftHalf = text.prefix(length)\n    let rightHalf = String(text.suffix(from: text.index(text.startIndex, offsetBy: length)).reversed())\n    return leftHalf + rightHalf\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"n\") == \"n\")"
    },
    {
        "id": 734,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var result = nums\n    var i = result.count - 1\n    while i >= 0 {\n        if result[i] % 2 == 0 {\n            result.remove(at: i)\n        }\n        i -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [5, 3, 3, 7]) == [5, 3, 3, 7])"
    },
    {
        "id": 735,
        "code": "import Foundation\n\nfunc f(sentence: String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n    var sentence = sentence\n    sentence = sentence.replacingOccurrences(of: \"(\", with: \"\")\n    sentence = sentence.replacingOccurrences(of: \")\", with: \"\")\n    sentence = sentence.replacingOccurrences(of: \" \", with: \"\")\n    return sentence.prefix(1).uppercased() + sentence.dropFirst().lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(sentence: \"(A (b B))\") == \"Abb\")"
    },
    {
        "id": 736,
        "code": "func f(text: String, insert: String) -> String {\n    let whitespaces: Set<Character> = [\"\\u{0009}\", \"\\u{000D}\", \"\\u{000B}\", \" \", \"\\u{000C}\", \"\\u{000A}\"]\n    var clean = \"\"\n    for char in text {\n        if whitespaces.contains(char) {\n            clean += insert\n        } else {\n            clean.append(char)\n        }\n    }\n    return clean\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"pi wa\", insert: \"chi\") == \"pichiwa\")"
    },
    {
        "id": 737,
        "code": "\n\n/// \nfunc f(nums: [Int]) -> Int {\n    var counts = 0\n    for i in nums {\n        if let _ = Int(String(i)) {\n            if counts == 0 {\n                counts += 1\n            }\n        }\n    }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [0, 6, 2, -1, -2]) == 1)"
    },
    {
        "id": 738,
        "code": "\n\n/// \nfunc f(text: String, characters: String) -> String {\n    var textToModify = text\n    for character in characters {\n        while textToModify.hasSuffix(String(character)) {\n            textToModify.removeLast()\n        }\n    }\n    return textToModify\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"r;r;r;r;r;r;r;r;r\", characters: \"x.r\") == \"r;r;r;r;r;r;r;r;\")"
    },
    {
        "id": 739,
        "code": "\n/// \nfunc f(st: String, pattern: [String]) -> Bool {\n    var str = st\n    for p in pattern {\n        if !str.hasPrefix(p) {\n            return false\n        }\n        str = String(str.dropFirst(p.count))\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(st: \"qwbnjrxs\", pattern: [\"jr\", \"b\", \"r\", \"qw\"]) == false)"
    },
    {
        "id": 740,
        "code": "\n/// \nfunc f(plot: [Int], delin: Int) -> [Int] {\n    if plot.contains(delin) {\n        if let split = plot.firstIndex(of: delin) {\n            let first = Array(plot[..<split])\n            let second = Array(plot[(split + 1)...])\n            return first + second\n        }\n    }\n    \n    return plot\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(plot: [1, 2, 3, 4], delin: 3) == [1, 2, 4])"
    },
    {
        "id": 741,
        "code": "\n/// \nfunc f(nums: [Int], p: Int) -> Int {\n    var prev_p = p - 1\n    if prev_p < 0 {\n        prev_p = nums.count - 1\n    }\n    return nums[prev_p]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [6, 8, 2, 5, 3, 1, 9, 7], p: 6) == 1)"
    },
    {
        "id": 742,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    var b = true\n    for x in text {\n        if x.isNumber {\n            b = true\n        } else {\n            b = false\n            break\n        }\n    }\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"-1-3\") == false)"
    },
    {
        "id": 743,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    let parts = text.split(separator: \",\")\n    let string_a = String(parts[0])\n    let string_b = String(parts[1])\n    return -(string_a.count + string_b.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"dog,cat\") == -6)"
    },
    {
        "id": 744,
        "code": "\n/// \nfunc f(text: String, new_ending: String) -> String {\n    var result = Array(text)\n    result.append(contentsOf: new_ending)\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"jro\", new_ending: \"wdlp\") == \"jrowdlp\")"
    },
    {
        "id": 745,
        "code": "import Foundation\n\nfunc f(address: String) -> String {\n    guard let atIndex = address.firstIndex(of: \"@\") else {\n        return address\n    }\n    \n    let suffixStart = address.index(after: atIndex)\n    let suffix = address[suffixStart...]\n    \n    if suffix.components(separatedBy: \".\").count > 2 {\n        let parts = suffix.split(separator: \".\")\n        let removeSuffix = parts.prefix(2).joined(separator: \".\")\n        if let range = address.range(of: removeSuffix, options: .backwards) {\n            return String(address[..<range.lowerBound])\n        }\n    }\n    \n    return address\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(address: \"minimc@minimc.io\") == \"minimc@minimc.io\")"
    },
    {
        "id": 746,
        "code": "func f(dct: [String : String]) -> [String : String] {\n    var result: [String: String] = [:]\n    for (key, value) in dct {\n        let item = value.split(separator: \".\")[0] + \"@pinc.uk\"\n        result[key] = String(item)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dct: [:] as [String : String]) == [:] as [String : String])"
    },
    {
        "id": 747,
        "code": "\n/// \nfunc f(text: String) -> Bool {\n    if text == \"42.42\" {\n        return true\n    }\n    for i in 3..<(text.count - 3) {\n        let index = text.index(text.startIndex, offsetBy: i)\n        if text[index] == \".\" && text.prefix(i).allSatisfy({ $0.isNumber }) && text.suffix(from: index).allSatisfy({ $0.isNumber }) {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"123E-10\") == false)"
    },
    {
        "id": 748
    },
    {
        "id": 749,
        "code": "\n\n/// \nfunc f(text: String, width: Int) -> String {\n    var result = \"\"\n    let lines = text.split(separator: \"\\n\")\n    for line in lines {\n        result += String(repeating: \" \", count: max(0, (width - line.count) / 2))\n        result += line\n        result += String(repeating: \" \", count: max(0, (width - line.count + 1) / 2))\n        result += \"\\n\"\n    }\n\n    // Remove the very last empty line\n    result = String(result.dropLast())\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"l\\nl\", width: 2) == \"l \\nl \")"
    },
    {
        "id": 750,
        "code": "\n/// \nfunc f(char_map: [String : String], text: String) -> String {\n    var new_text = \"\"\n    for ch in text {\n        if let val = char_map[String(ch)] {\n            new_text += val\n        } else {\n            new_text += String(ch)\n        }\n    }\n    return new_text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(char_map: [:] as [String : String], text: \"hbd\") == \"hbd\")"
    },
    {
        "id": 751,
        "code": "\n/// \nfunc f(text: String, char: String, min_count: Int) -> String {\n    let count = text.filter { $0 == Character(char) }.count\n    if count < min_count {\n        return text.uppercased()\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"wwwwhhhtttpp\", char: \"w\", min_count: 3) == \"wwwwhhhtttpp\")"
    },
    {
        "id": 752,
        "code": "\n/// \nfunc f(s: String, amount: Int) -> String {\n    return String(repeating: \"z\", count: max(amount - s.count, 0)) + s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"abc\", amount: 8) == \"zzzzzabc\")"
    },
    {
        "id": 753,
        "code": "\n/// \nfunc f(bag: [Int : Int]) -> [Int : Int] {\n    var values = Array(bag.values)\n    var tbl: [Int: Int] = [:]\n    for v in 0..<100 {\n        if values.contains(v) {\n            tbl[v] = values.filter { $0 == v }.count\n        }\n    }\n    return tbl\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(bag: [0 : 0, 1 : 0, 2 : 0, 3 : 0, 4 : 0]) == [0 : 5])"
    },
    {
        "id": 754,
        "code": "\nimport Foundation\n\nfunc f(nums: [String]) -> [String] {\n    return nums.dropFirst().map { val in\n        String(format: \"%0\\(nums[0])d\", Int(val) ?? 0)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [\"1\", \"2\", \"2\", \"44\", \"0\", \"7\", \"20257\"]) == [\"2\", \"2\", \"44\", \"0\", \"7\", \"20257\"])"
    },
    {
        "id": 755,
        "code": "\nimport Foundation\n\nfunc f(replace: String, text: String, hide: String) -> String {\n    var tempReplace = replace\n    var tempText = text\n    while tempText.contains(hide) {\n        tempReplace += \"ax\"\n        tempText = tempText.replacingOccurrences(of: hide, with: tempReplace)\n    }\n    return tempText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(replace: \"###\", text: \"ph>t#A#BiEcDefW#ON#iiNCU\", hide: \".\") == \"ph>t#A#BiEcDefW#ON#iiNCU\")"
    },
    {
        "id": 756
    },
    {
        "id": 757,
        "code": "\nimport Foundation\n\nfunc f(text: String, char: String, replace: String) -> String {\n    return text.replacingOccurrences(of: char, with: replace)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"a1a8\", char: \"1\", replace: \"n2\") == \"an2a8\")"
    },
    {
        "id": 758,
        "code": "\n/// \nfunc f(nums: [Int]) -> Bool {\n    if nums.reversed() == nums {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [0, 3, 6, 2]) == false)"
    },
    {
        "id": 759,
        "code": "import Foundation\n\nfunc f(text: String, sub: String) -> [Int] {\n    var index: [Int] = []\n    var starting = text.startIndex\n    \n    while let range = text.range(of: sub, range: starting..<text.endIndex) {\n        let pos = text.distance(from: text.startIndex, to: range.lowerBound)\n        index.append(pos)\n        starting = text.index(range.lowerBound, offsetBy: sub.count)\n    }\n    \n    return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"egmdartoa\", sub: \"good\") == [] as [Int])"
    },
    {
        "id": 760
    },
    {
        "id": 761,
        "code": "\n/// \nfunc f(array: [Int]) -> [Int] {\n    var output = array\n    output[0..<output.count].forEach { index in\n        if index % 2 == 0 {\n            output[index] = array[array.count - 1 - index]\n        }\n    }\n    return output.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(array: [] as [Int]) == [] as [Int])"
    },
    {
        "id": 762,
        "code": "func f(text: String) -> String {\n    let lowercasedText = text.lowercased()\n    let capitalizedText = lowercasedText.prefix(1).uppercased() + lowercasedText.dropFirst()\n    return String(lowercasedText.prefix(1)) + String(capitalizedText.dropFirst())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"this And cPanel\") == \"this and cpanel\")"
    },
    {
        "id": 763,
        "code": "import Foundation\n\nfunc f(values: String, text: String, markers: String) -> String {\n    return text.trimmingCharacters(in: NSCharacterSet(charactersIn: values + markers) as CharacterSet)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(values: \"2Pn\", text: \"yCxpg2C2Pny2\", markers: \"\") == \"yCxpg2C2Pny\")"
    },
    {
        "id": 764
    },
    {
        "id": 765,
        "code": "\n/// \nfunc f(text: String) -> Int {\n    return text.reduce(0) { $0 + ($1.isNumber ? 1 : 0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"so456\") == 3)"
    },
    {
        "id": 766,
        "code": "\n/// \nfunc f(values: [String], value: Int) -> [String : Int] {\n    var newDict = [String: Int]()\n    let sortedValues = values.joined().sorted().map { String($0) }.joined()\n    \n    for val in values {\n        newDict[val] = value\n    }\n    \n    newDict[sortedValues] = value * 3\n    \n    return newDict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(values: [\"0\", \"3\"], value: 117) == [\"0\" : 117, \"3\" : 117, \"03\" : 351])"
    },
    {
        "id": 767,
        "code": "import Foundation\n\nfunc f(text: String) -> String {\n    let a = text.trimmingCharacters(in: CharacterSet.whitespaces).split(separator: \" \")\n    for element in a {\n        if !element.allSatisfy({ $0.isNumber }) {\n            return \"-\"\n        }\n    }\n    return a.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"d khqw whi fwi bbn 41\") == \"-\")"
    },
    {
        "id": 768,
        "code": "\nimport Foundation\n\nfunc f(s: String, o: String) -> String {\n    if s.hasPrefix(o) {\n        return s\n    }\n    let reversedO = String(o.reversed())\n    let startIndex = reversedO.index(reversedO.startIndex, offsetBy: 1)\n    let endIndex = reversedO.endIndex\n    let slicedO = String(reversedO[startIndex..<endIndex])\n    return o + f(s: s, o: slicedO)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"abba\", o: \"bab\") == \"bababba\")"
    },
    {
        "id": 769,
        "code": "\n/// \nfunc f(text: String) -> String {\n    var textList = text.map { String($0) }\n    for (index, char) in textList.enumerated() {\n        textList[index] = char.uppercased() == char ? char.lowercased() : char.uppercased()\n    }\n    \n    return textList.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"akA?riu\") == \"AKa?RIU\")"
    },
    {
        "id": 770
    },
    {
        "id": 771,
        "code": "\n\n/// \nfunc f(items: [Int]) -> [Int] {\n    var oddPositioned: [Int] = []\n    var mutableItems = items\n    while mutableItems.count > 0 {\n        let position = mutableItems.firstIndex(of: mutableItems.min()!) ?? 0\n        mutableItems.remove(at: position)\n        let item = mutableItems.remove(at: position)\n        oddPositioned.append(item)\n    }\n    return oddPositioned\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(items: [1, 2, 3, 4, 5, 6, 7, 8]) == [2, 4, 6, 8])"
    },
    {
        "id": 772,
        "code": "\n/// \nfunc f(phrase: String) -> String {\n    var result = \"\"\n    for i in phrase {\n        if !i.isLowercase {\n            result.append(i)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(phrase: \"serjgpoDFdbcA.\") == \"DFA.\")"
    },
    {
        "id": 773,
        "code": "\n/// \nfunc f(nums: [Int], n: Int) -> Int {\n    var numsCopy = nums\n    return numsCopy.remove(at: n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [-7, 3, 1, -1, -1, 0, 4], n: 6) == 4)"
    },
    {
        "id": 774,
        "code": "\n/// \nfunc f(num: Int, name: String) -> String {\n    let f_str = \"quiz leader = \\(name), count = \\(num)\"\n    return f_str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(num: 23, name: \"Cornareti\") == \"quiz leader = Cornareti, count = 23\")"
    },
    {
        "id": 775,
        "code": "\n/// \nfunc f(nums: [Int]) -> [Int] {\n    var reversedNums = nums\n    let count = reversedNums.count\n    for i in 0..<(count / 2) {\n        let temp = reversedNums[i]\n        reversedNums[i] = reversedNums[count - i - 1]\n        reversedNums[count - i - 1] = temp\n    }\n    return reversedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [2, 6, 1, 3, 1]) == [1, 3, 1, 6, 2])"
    },
    {
        "id": 776,
        "code": "func f(dictionary: [Int : Int]) -> [String : Int] {\n    var a = dictionary\n    var updatedDictionary: [String : Int] = [:]\n    \n    for (key, value) in a {\n        if key % 2 != 0 {\n            a.removeValue(forKey: key)\n            updatedDictionary[\"$\\(key)\"] = value\n        }\n    }\n    \n    return updatedDictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(dictionary: [:] as [Int : Int]) == [:] as [String : Int])"
    },
    {
        "id": 777,
        "code": "\nimport Foundation\n\nfunc f(names: [String], excluded: String) -> [String] {\n    var newNames = names\n    for i in 0..<newNames.count {\n        if newNames[i].contains(excluded) {\n            newNames[i] = newNames[i].replacingOccurrences(of: excluded, with: \"\")\n        }\n    }\n    return newNames\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(names: [\"avc  a .d e\"], excluded: \"\") == [\"avc  a .d e\"])"
    },
    {
        "id": 778,
        "code": "\n/// \nfunc f(prefix: String, text: String) -> String {\n    if text.hasPrefix(prefix) {\n        return text\n    } else {\n        return prefix + text\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(prefix: \"mjs\", text: \"mjqwmjsqjwisojqwiso\") == \"mjsmjqwmjsqjwisojqwiso\")"
    },
    {
        "id": 779
    },
    {
        "id": 780,
        "code": "\n/// \nfunc f(ints: [Int]) -> String {\n    var counts = Array(repeating: 0, count: 301)\n    \n    for i in ints {\n        counts[i] += 1\n    }\n    \n    var r = [String]()\n    for i in 0..<counts.count {\n        if counts[i] >= 3 {\n            r.append(String(i))\n        }\n    }\n    counts.removeAll()\n    return r.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(ints: [2, 3, 5, 2, 4, 5, 2, 89]) == \"2\")"
    },
    {
        "id": 781,
        "code": "import Foundation\n\nfunc f(s: String, ch: String) -> String {\n    if !s.contains(ch) {\n        return \"\"\n    }\n    \n    var s = s.components(separatedBy: ch).dropFirst().joined(separator: ch).reversed()\n    for _ in 0..<s.count {\n        s = String(s).components(separatedBy: ch).dropFirst().joined(separator: ch).reversed()\n    }\n    \n    return String(s)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(s: \"shivajimonto6\", ch: \"6\") == \"\")"
    },
    {
        "id": 782,
        "code": "\n/// \nfunc f(input: String) -> Bool {\n    for char in input {\n        if char.isUppercase {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(input: \"a j c n x X k\") == false)"
    },
    {
        "id": 783,
        "code": "\n/// \nfunc f(text: String, comparison: String) -> Int {\n    let length = comparison.count\n    if length <= text.count {\n        for i in 0..<length {\n            if comparison[comparison.index(comparison.startIndex, offsetBy: length - i - 1)] != text[text.index(text.endIndex, offsetBy: -i - 1)] {\n                return i\n            }\n        }\n    }\n    return length\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"managed\", comparison: \"\") == 0)"
    },
    {
        "id": 784,
        "code": "\n\n/// \nfunc f(key: String, value: String) -> (String, String) {\n    var dict: [String: String] = [key: value]\n    let item = dict.removeValue(forKey: key)\n    return (key, item ?? \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(key: \"read\", value: \"Is\") == (\"read\", \"Is\"))"
    },
    {
        "id": 785
    },
    {
        "id": 786,
        "code": "\n/// \nfunc f(text: String, letter: String) -> String {\n    if let start = text.firstIndex(of: Character(letter)) {\n        let startIndex = text.index(after: start)\n        return String(text[startIndex...]) + String(text[..<startIndex])\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"19kefp7\", letter: \"9\") == \"kefp719\")"
    },
    {
        "id": 787,
        "code": "\n/// \nfunc f(text: String) -> String {\n    if text.isEmpty {\n        return \"\"\n    }\n    \n    let lowercasedText = text.lowercased()\n    let firstChar = lowercasedText.prefix(1).uppercased()\n    let restOfString = String(lowercasedText.dropFirst())\n    \n    return firstChar + restOfString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"xzd\") == \"Xzd\")"
    },
    {
        "id": 788,
        "code": "\n/// \nfunc f(text: String, suffix: String) -> String {\n    if suffix.hasPrefix(\"/\") {\n        return text + String(suffix.dropFirst())\n    }\n    return text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"hello.txt\", suffix: \"/\") == \"hello.txt\")"
    },
    {
        "id": 789,
        "code": "\n/// \nfunc f(text: String, n: Int) -> String {\n    if n < 0 || text.count <= n {\n        return text\n    }\n    let result = text.prefix(n)\n    var i = result.count - 1\n    while i >= 0 {\n        if result[result.index(result.startIndex, offsetBy: i)] != text[text.index(text.startIndex, offsetBy: i)] {\n            break\n        }\n        i -= 1\n    }\n    return String(text.prefix(i + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"bR\", n: -1) == \"bR\")"
    },
    {
        "id": 790
    },
    {
        "id": 791,
        "code": "\n/// \nfunc f(integer: Int, n: Int) -> String {\n    var i = 1\n    var text = String(integer)\n    while i + text.count < n {\n        i += text.count\n    }\n    return String(repeating: \"0\", count: i) + text\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(integer: 8999, n: 2) == \"08999\")"
    },
    {
        "id": 792,
        "code": "\n\nfunc f(l1: [String], l2: [String]) -> [String : [String]] {\n    if l1.count != l2.count {\n        return [:]\n    }\n    var dictionary = [String: [String]]()\n    for i in 0..<l1.count {\n        dictionary[l1[i]] = l2\n    }\n    return dictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(l1: [\"a\", \"b\"], l2: [\"car\", \"dog\"]) == [\"a\" : [\"car\", \"dog\"], \"b\" : [\"car\", \"dog\"]])"
    },
    {
        "id": 793,
        "code": "\n/// \nfunc f(lst: [Int], start: Int, end: Int) -> Int {\n    var count = 0\n    for i in start..<end {\n        for j in i..<end {\n            if lst[i] != lst[j] {\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(lst: [1, 2, 4, 3, 2, 1], start: 0, end: 3) == 3)"
    },
    {
        "id": 794,
        "code": "\n/// \nfunc f(line: String) -> String {\n    var a: [Character] = []\n    for c in line {\n        if c.isLetter || c.isNumber {\n            a.append(c)\n        }\n    }\n    return String(a)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(line: \"\\\"\\\\%$ normal chars $%~ qwet42'\") == \"normalcharsqwet42\")"
    },
    {
        "id": 795
    },
    {
        "id": 796,
        "code": "\n/// \nfunc f(str: String, toget: String) -> String {\n    if str.hasPrefix(toget) {\n        return String(str.dropFirst(toget.count))\n    } else {\n        return str\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(str: \"fnuiyh\", toget: \"ni\") == \"fnuiyh\")"
    },
    {
        "id": 797
    },
    {
        "id": 798,
        "code": "\n/// \nfunc f(text: String, pre: String) -> String {\n    if !text.hasPrefix(pre) {\n        return text\n    }\n    return String(text.dropFirst(pre.count))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(text: \"@hihu@!\", pre: \"@hihu\") == \"@!\")"
    },
    {
        "id": 799,
        "code": "func f(st: String) -> String {\n    if st.first == \"~\" {\n        let e = String(repeating: \"s\", count: max(0, 10 - st.count)) + st\n        return f(st: e)\n    } else {\n        return String(repeating: \"n\", count: max(0, 10 - st.count)) + st\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(st: \"eqe-;ew22\") == \"neqe-;ew22\")"
    }
]